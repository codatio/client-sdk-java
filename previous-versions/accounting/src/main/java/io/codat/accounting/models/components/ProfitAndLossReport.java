/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.accounting.models.components;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.accounting.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.util.Optional;


public class ProfitAndLossReport {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("costOfSales")
    private Optional<? extends ReportLineInput> costOfSales;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expenses")
    private Optional<? extends ReportLineInput> expenses;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fromDate")
    private Optional<? extends String> fromDate;

    /**
     * Gross profit of the company in the given date range.
     */
    @JsonProperty("grossProfit")
    private double grossProfit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("income")
    private Optional<? extends ReportLineInput> income;

    /**
     * Net operating profit of the company in the given date range.
     */
    @JsonProperty("netOperatingProfit")
    private double netOperatingProfit;

    /**
     * Net other income of the company in the given date range.
     */
    @JsonProperty("netOtherIncome")
    private double netOtherIncome;

    /**
     * Net profit of the company in the given date range.
     */
    @JsonProperty("netProfit")
    private double netProfit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("otherExpenses")
    private Optional<? extends ReportLineInput> otherExpenses;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("otherIncome")
    private Optional<? extends ReportLineInput> otherIncome;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("toDate")
    private Optional<? extends String> toDate;

    public ProfitAndLossReport(
            @JsonProperty("costOfSales") Optional<? extends ReportLineInput> costOfSales,
            @JsonProperty("expenses") Optional<? extends ReportLineInput> expenses,
            @JsonProperty("fromDate") Optional<? extends String> fromDate,
            @JsonProperty("grossProfit") double grossProfit,
            @JsonProperty("income") Optional<? extends ReportLineInput> income,
            @JsonProperty("netOperatingProfit") double netOperatingProfit,
            @JsonProperty("netOtherIncome") double netOtherIncome,
            @JsonProperty("netProfit") double netProfit,
            @JsonProperty("otherExpenses") Optional<? extends ReportLineInput> otherExpenses,
            @JsonProperty("otherIncome") Optional<? extends ReportLineInput> otherIncome,
            @JsonProperty("toDate") Optional<? extends String> toDate) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        Utils.checkNotNull(expenses, "expenses");
        Utils.checkNotNull(fromDate, "fromDate");
        Utils.checkNotNull(grossProfit, "grossProfit");
        Utils.checkNotNull(income, "income");
        Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
        Utils.checkNotNull(netOtherIncome, "netOtherIncome");
        Utils.checkNotNull(netProfit, "netProfit");
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        Utils.checkNotNull(otherIncome, "otherIncome");
        Utils.checkNotNull(toDate, "toDate");
        this.costOfSales = costOfSales;
        this.expenses = expenses;
        this.fromDate = fromDate;
        this.grossProfit = grossProfit;
        this.income = income;
        this.netOperatingProfit = netOperatingProfit;
        this.netOtherIncome = netOtherIncome;
        this.netProfit = netProfit;
        this.otherExpenses = otherExpenses;
        this.otherIncome = otherIncome;
        this.toDate = toDate;
    }

    public Optional<? extends ReportLineInput> costOfSales() {
        return costOfSales;
    }

    public Optional<? extends ReportLineInput> expenses() {
        return expenses;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> fromDate() {
        return fromDate;
    }

    /**
     * Gross profit of the company in the given date range.
     */
    public double grossProfit() {
        return grossProfit;
    }

    public Optional<? extends ReportLineInput> income() {
        return income;
    }

    /**
     * Net operating profit of the company in the given date range.
     */
    public double netOperatingProfit() {
        return netOperatingProfit;
    }

    /**
     * Net other income of the company in the given date range.
     */
    public double netOtherIncome() {
        return netOtherIncome;
    }

    /**
     * Net profit of the company in the given date range.
     */
    public double netProfit() {
        return netProfit;
    }

    public Optional<? extends ReportLineInput> otherExpenses() {
        return otherExpenses;
    }

    public Optional<? extends ReportLineInput> otherIncome() {
        return otherIncome;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> toDate() {
        return toDate;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    public ProfitAndLossReport withCostOfSales(ReportLineInput costOfSales) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        this.costOfSales = Optional.ofNullable(costOfSales);
        return this;
    }
    
    public ProfitAndLossReport withCostOfSales(Optional<? extends ReportLineInput> costOfSales) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        this.costOfSales = costOfSales;
        return this;
    }

    public ProfitAndLossReport withExpenses(ReportLineInput expenses) {
        Utils.checkNotNull(expenses, "expenses");
        this.expenses = Optional.ofNullable(expenses);
        return this;
    }
    
    public ProfitAndLossReport withExpenses(Optional<? extends ReportLineInput> expenses) {
        Utils.checkNotNull(expenses, "expenses");
        this.expenses = expenses;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withFromDate(String fromDate) {
        Utils.checkNotNull(fromDate, "fromDate");
        this.fromDate = Optional.ofNullable(fromDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withFromDate(Optional<? extends String> fromDate) {
        Utils.checkNotNull(fromDate, "fromDate");
        this.fromDate = fromDate;
        return this;
    }

    /**
     * Gross profit of the company in the given date range.
     */
    public ProfitAndLossReport withGrossProfit(double grossProfit) {
        Utils.checkNotNull(grossProfit, "grossProfit");
        this.grossProfit = grossProfit;
        return this;
    }

    public ProfitAndLossReport withIncome(ReportLineInput income) {
        Utils.checkNotNull(income, "income");
        this.income = Optional.ofNullable(income);
        return this;
    }
    
    public ProfitAndLossReport withIncome(Optional<? extends ReportLineInput> income) {
        Utils.checkNotNull(income, "income");
        this.income = income;
        return this;
    }

    /**
     * Net operating profit of the company in the given date range.
     */
    public ProfitAndLossReport withNetOperatingProfit(double netOperatingProfit) {
        Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
        this.netOperatingProfit = netOperatingProfit;
        return this;
    }

    /**
     * Net other income of the company in the given date range.
     */
    public ProfitAndLossReport withNetOtherIncome(double netOtherIncome) {
        Utils.checkNotNull(netOtherIncome, "netOtherIncome");
        this.netOtherIncome = netOtherIncome;
        return this;
    }

    /**
     * Net profit of the company in the given date range.
     */
    public ProfitAndLossReport withNetProfit(double netProfit) {
        Utils.checkNotNull(netProfit, "netProfit");
        this.netProfit = netProfit;
        return this;
    }

    public ProfitAndLossReport withOtherExpenses(ReportLineInput otherExpenses) {
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        this.otherExpenses = Optional.ofNullable(otherExpenses);
        return this;
    }
    
    public ProfitAndLossReport withOtherExpenses(Optional<? extends ReportLineInput> otherExpenses) {
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        this.otherExpenses = otherExpenses;
        return this;
    }

    public ProfitAndLossReport withOtherIncome(ReportLineInput otherIncome) {
        Utils.checkNotNull(otherIncome, "otherIncome");
        this.otherIncome = Optional.ofNullable(otherIncome);
        return this;
    }
    
    public ProfitAndLossReport withOtherIncome(Optional<? extends ReportLineInput> otherIncome) {
        Utils.checkNotNull(otherIncome, "otherIncome");
        this.otherIncome = otherIncome;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withToDate(String toDate) {
        Utils.checkNotNull(toDate, "toDate");
        this.toDate = Optional.ofNullable(toDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withToDate(Optional<? extends String> toDate) {
        Utils.checkNotNull(toDate, "toDate");
        this.toDate = toDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ProfitAndLossReport other = (ProfitAndLossReport) o;
        return 
            java.util.Objects.deepEquals(this.costOfSales, other.costOfSales) &&
            java.util.Objects.deepEquals(this.expenses, other.expenses) &&
            java.util.Objects.deepEquals(this.fromDate, other.fromDate) &&
            java.util.Objects.deepEquals(this.grossProfit, other.grossProfit) &&
            java.util.Objects.deepEquals(this.income, other.income) &&
            java.util.Objects.deepEquals(this.netOperatingProfit, other.netOperatingProfit) &&
            java.util.Objects.deepEquals(this.netOtherIncome, other.netOtherIncome) &&
            java.util.Objects.deepEquals(this.netProfit, other.netProfit) &&
            java.util.Objects.deepEquals(this.otherExpenses, other.otherExpenses) &&
            java.util.Objects.deepEquals(this.otherIncome, other.otherIncome) &&
            java.util.Objects.deepEquals(this.toDate, other.toDate);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            costOfSales,
            expenses,
            fromDate,
            grossProfit,
            income,
            netOperatingProfit,
            netOtherIncome,
            netProfit,
            otherExpenses,
            otherIncome,
            toDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ProfitAndLossReport.class,
                "costOfSales", costOfSales,
                "expenses", expenses,
                "fromDate", fromDate,
                "grossProfit", grossProfit,
                "income", income,
                "netOperatingProfit", netOperatingProfit,
                "netOtherIncome", netOtherIncome,
                "netProfit", netProfit,
                "otherExpenses", otherExpenses,
                "otherIncome", otherIncome,
                "toDate", toDate);
    }
    
    public final static class Builder {
 
        private Optional<? extends ReportLineInput> costOfSales = Optional.empty();
 
        private Optional<? extends ReportLineInput> expenses = Optional.empty();
 
        private Optional<? extends String> fromDate = Optional.empty();
 
        private Double grossProfit;
 
        private Optional<? extends ReportLineInput> income = Optional.empty();
 
        private Double netOperatingProfit;
 
        private Double netOtherIncome;
 
        private Double netProfit;
 
        private Optional<? extends ReportLineInput> otherExpenses = Optional.empty();
 
        private Optional<? extends ReportLineInput> otherIncome = Optional.empty();
 
        private Optional<? extends String> toDate = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder costOfSales(ReportLineInput costOfSales) {
            Utils.checkNotNull(costOfSales, "costOfSales");
            this.costOfSales = Optional.ofNullable(costOfSales);
            return this;
        }
        
        public Builder costOfSales(Optional<? extends ReportLineInput> costOfSales) {
            Utils.checkNotNull(costOfSales, "costOfSales");
            this.costOfSales = costOfSales;
            return this;
        }

        public Builder expenses(ReportLineInput expenses) {
            Utils.checkNotNull(expenses, "expenses");
            this.expenses = Optional.ofNullable(expenses);
            return this;
        }
        
        public Builder expenses(Optional<? extends ReportLineInput> expenses) {
            Utils.checkNotNull(expenses, "expenses");
            this.expenses = expenses;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder fromDate(String fromDate) {
            Utils.checkNotNull(fromDate, "fromDate");
            this.fromDate = Optional.ofNullable(fromDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder fromDate(Optional<? extends String> fromDate) {
            Utils.checkNotNull(fromDate, "fromDate");
            this.fromDate = fromDate;
            return this;
        }

        /**
         * Gross profit of the company in the given date range.
         */
        public Builder grossProfit(double grossProfit) {
            Utils.checkNotNull(grossProfit, "grossProfit");
            this.grossProfit = grossProfit;
            return this;
        }

        public Builder income(ReportLineInput income) {
            Utils.checkNotNull(income, "income");
            this.income = Optional.ofNullable(income);
            return this;
        }
        
        public Builder income(Optional<? extends ReportLineInput> income) {
            Utils.checkNotNull(income, "income");
            this.income = income;
            return this;
        }

        /**
         * Net operating profit of the company in the given date range.
         */
        public Builder netOperatingProfit(double netOperatingProfit) {
            Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
            this.netOperatingProfit = netOperatingProfit;
            return this;
        }

        /**
         * Net other income of the company in the given date range.
         */
        public Builder netOtherIncome(double netOtherIncome) {
            Utils.checkNotNull(netOtherIncome, "netOtherIncome");
            this.netOtherIncome = netOtherIncome;
            return this;
        }

        /**
         * Net profit of the company in the given date range.
         */
        public Builder netProfit(double netProfit) {
            Utils.checkNotNull(netProfit, "netProfit");
            this.netProfit = netProfit;
            return this;
        }

        public Builder otherExpenses(ReportLineInput otherExpenses) {
            Utils.checkNotNull(otherExpenses, "otherExpenses");
            this.otherExpenses = Optional.ofNullable(otherExpenses);
            return this;
        }
        
        public Builder otherExpenses(Optional<? extends ReportLineInput> otherExpenses) {
            Utils.checkNotNull(otherExpenses, "otherExpenses");
            this.otherExpenses = otherExpenses;
            return this;
        }

        public Builder otherIncome(ReportLineInput otherIncome) {
            Utils.checkNotNull(otherIncome, "otherIncome");
            this.otherIncome = Optional.ofNullable(otherIncome);
            return this;
        }
        
        public Builder otherIncome(Optional<? extends ReportLineInput> otherIncome) {
            Utils.checkNotNull(otherIncome, "otherIncome");
            this.otherIncome = otherIncome;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder toDate(String toDate) {
            Utils.checkNotNull(toDate, "toDate");
            this.toDate = Optional.ofNullable(toDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder toDate(Optional<? extends String> toDate) {
            Utils.checkNotNull(toDate, "toDate");
            this.toDate = toDate;
            return this;
        }
        
        public ProfitAndLossReport build() {
            return new ProfitAndLossReport(
                costOfSales,
                expenses,
                fromDate,
                grossProfit,
                income,
                netOperatingProfit,
                netOtherIncome,
                netProfit,
                otherExpenses,
                otherIncome,
                toDate);
        }
    }
}

