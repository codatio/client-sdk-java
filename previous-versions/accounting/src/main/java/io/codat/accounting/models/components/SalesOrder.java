/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.accounting.models.components;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.accounting.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * SalesOrder - &gt; View the coverage for sales orders in the &lt;a className="external" href="https://knowledge.codat.io/supported-features/accounting?view=tab-by-data-type&amp;dataType=salesOrders" target="_blank"&gt;Data coverage explorer&lt;/a&gt;.
 * 
 * ## Overview
 * 
 * A sales order represents a customer's intention to purchase goods or services from a seller and usually includes information such as the expected delivery date and shipping details. This information can be used to provide visibility on a business's expected receivables and to track sales through the full procurement process.
 * 
 * A sales order is typically converted to an [invoice](https://docs.codat.io/accounting-api#/schemas/Invoice) after approval.
 */

public class SalesOrder {

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<? extends String> currency;

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currencyRate")
    private JsonNullable<? extends Double> currencyRate;

    /**
     * A customer-supplied identifier for the purchase order in the customer's system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerPurchaseOrderNumber")
    private JsonNullable<? extends String> customerPurchaseOrderNumber;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerRef")
    private Optional<? extends AccountingCustomerRef> customerRef;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expectedDeliveryDate")
    private Optional<? extends String> expectedDeliveryDate;

    /**
     * Identifier for the sales order, unique for the company in the accounting platform.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<? extends String> id;

    /**
     * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoicingStatus")
    private Optional<? extends SalesOrderInvoiceStatus> invoicingStatus;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issueDate")
    private Optional<? extends String> issueDate;

    /**
     * An array of line items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lineItems")
    private JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends Metadata> metadata;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<? extends String> modifiedDate;

    /**
     * Any additional information associated with the sales order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private JsonNullable<? extends String> note;

    /**
     * Friendly reference for the sales order, commonly generated by the accounting platform.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("salesOrderNumber")
    private JsonNullable<? extends String> salesOrderNumber;

    /**
     * Delivery details for any goods that have been ordered.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shipTo")
    private Optional<? extends SalesOrderShipTo> shipTo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<? extends String> sourceModifiedDate;

    /**
     * Current state of the sales order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends SalesOrderStatus> status;

    /**
     * Total amount of the sales order, including discounts but excluding tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subTotal")
    private Optional<? extends Double> subTotal;

    /**
     * Total amount of the sales order, including discounts and tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalAmount")
    private Optional<? extends Double> totalAmount;

    /**
     * Total value of any discounts applied to the sales order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalDiscount")
    private Optional<? extends Double> totalDiscount;

    /**
     * Total amount of tax included in the sales order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalTaxAmount")
    private Optional<? extends Double> totalTaxAmount;

    public SalesOrder(
            @JsonProperty("currency") Optional<? extends String> currency,
            @JsonProperty("currencyRate") JsonNullable<? extends Double> currencyRate,
            @JsonProperty("customerPurchaseOrderNumber") JsonNullable<? extends String> customerPurchaseOrderNumber,
            @JsonProperty("customerRef") Optional<? extends AccountingCustomerRef> customerRef,
            @JsonProperty("expectedDeliveryDate") Optional<? extends String> expectedDeliveryDate,
            @JsonProperty("id") Optional<? extends String> id,
            @JsonProperty("invoicingStatus") Optional<? extends SalesOrderInvoiceStatus> invoicingStatus,
            @JsonProperty("issueDate") Optional<? extends String> issueDate,
            @JsonProperty("lineItems") JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems,
            @JsonProperty("metadata") Optional<? extends Metadata> metadata,
            @JsonProperty("modifiedDate") Optional<? extends String> modifiedDate,
            @JsonProperty("note") JsonNullable<? extends String> note,
            @JsonProperty("salesOrderNumber") JsonNullable<? extends String> salesOrderNumber,
            @JsonProperty("shipTo") Optional<? extends SalesOrderShipTo> shipTo,
            @JsonProperty("sourceModifiedDate") Optional<? extends String> sourceModifiedDate,
            @JsonProperty("status") Optional<? extends SalesOrderStatus> status,
            @JsonProperty("subTotal") Optional<? extends Double> subTotal,
            @JsonProperty("totalAmount") Optional<? extends Double> totalAmount,
            @JsonProperty("totalDiscount") Optional<? extends Double> totalDiscount,
            @JsonProperty("totalTaxAmount") Optional<? extends Double> totalTaxAmount) {
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(customerPurchaseOrderNumber, "customerPurchaseOrderNumber");
        Utils.checkNotNull(customerRef, "customerRef");
        Utils.checkNotNull(expectedDeliveryDate, "expectedDeliveryDate");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(invoicingStatus, "invoicingStatus");
        Utils.checkNotNull(issueDate, "issueDate");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(note, "note");
        Utils.checkNotNull(salesOrderNumber, "salesOrderNumber");
        Utils.checkNotNull(shipTo, "shipTo");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.customerPurchaseOrderNumber = customerPurchaseOrderNumber;
        this.customerRef = customerRef;
        this.expectedDeliveryDate = expectedDeliveryDate;
        this.id = id;
        this.invoicingStatus = invoicingStatus;
        this.issueDate = issueDate;
        this.lineItems = lineItems;
        this.metadata = metadata;
        this.modifiedDate = modifiedDate;
        this.note = note;
        this.salesOrderNumber = salesOrderNumber;
        this.shipTo = shipTo;
        this.sourceModifiedDate = sourceModifiedDate;
        this.status = status;
        this.subTotal = subTotal;
        this.totalAmount = totalAmount;
        this.totalDiscount = totalDiscount;
        this.totalTaxAmount = totalTaxAmount;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public Optional<? extends String> currency() {
        return currency;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public JsonNullable<? extends Double> currencyRate() {
        return currencyRate;
    }

    /**
     * A customer-supplied identifier for the purchase order in the customer's system.
     */
    public JsonNullable<? extends String> customerPurchaseOrderNumber() {
        return customerPurchaseOrderNumber;
    }

    public Optional<? extends AccountingCustomerRef> customerRef() {
        return customerRef;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> expectedDeliveryDate() {
        return expectedDeliveryDate;
    }

    /**
     * Identifier for the sales order, unique for the company in the accounting platform.
     */
    public Optional<? extends String> id() {
        return id;
    }

    /**
     * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
     */
    public Optional<? extends SalesOrderInvoiceStatus> invoicingStatus() {
        return invoicingStatus;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> issueDate() {
        return issueDate;
    }

    /**
     * An array of line items.
     */
    public JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems() {
        return lineItems;
    }

    public Optional<? extends Metadata> metadata() {
        return metadata;
    }

    public Optional<? extends String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Any additional information associated with the sales order.
     */
    public JsonNullable<? extends String> note() {
        return note;
    }

    /**
     * Friendly reference for the sales order, commonly generated by the accounting platform.
     */
    public JsonNullable<? extends String> salesOrderNumber() {
        return salesOrderNumber;
    }

    /**
     * Delivery details for any goods that have been ordered.
     */
    public Optional<? extends SalesOrderShipTo> shipTo() {
        return shipTo;
    }

    public Optional<? extends String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * Current state of the sales order.
     */
    public Optional<? extends SalesOrderStatus> status() {
        return status;
    }

    /**
     * Total amount of the sales order, including discounts but excluding tax.
     */
    public Optional<? extends Double> subTotal() {
        return subTotal;
    }

    /**
     * Total amount of the sales order, including discounts and tax.
     */
    public Optional<? extends Double> totalAmount() {
        return totalAmount;
    }

    /**
     * Total value of any discounts applied to the sales order.
     */
    public Optional<? extends Double> totalDiscount() {
        return totalDiscount;
    }

    /**
     * Total amount of tax included in the sales order.
     */
    public Optional<? extends Double> totalTaxAmount() {
        return totalTaxAmount;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public SalesOrder withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }
    
    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public SalesOrder withCurrency(Optional<? extends String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public SalesOrder withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public SalesOrder withCurrencyRate(JsonNullable<? extends Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    /**
     * A customer-supplied identifier for the purchase order in the customer's system.
     */
    public SalesOrder withCustomerPurchaseOrderNumber(String customerPurchaseOrderNumber) {
        Utils.checkNotNull(customerPurchaseOrderNumber, "customerPurchaseOrderNumber");
        this.customerPurchaseOrderNumber = JsonNullable.of(customerPurchaseOrderNumber);
        return this;
    }

    /**
     * A customer-supplied identifier for the purchase order in the customer's system.
     */
    public SalesOrder withCustomerPurchaseOrderNumber(JsonNullable<? extends String> customerPurchaseOrderNumber) {
        Utils.checkNotNull(customerPurchaseOrderNumber, "customerPurchaseOrderNumber");
        this.customerPurchaseOrderNumber = customerPurchaseOrderNumber;
        return this;
    }

    public SalesOrder withCustomerRef(AccountingCustomerRef customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = Optional.ofNullable(customerRef);
        return this;
    }
    
    public SalesOrder withCustomerRef(Optional<? extends AccountingCustomerRef> customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = customerRef;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public SalesOrder withExpectedDeliveryDate(String expectedDeliveryDate) {
        Utils.checkNotNull(expectedDeliveryDate, "expectedDeliveryDate");
        this.expectedDeliveryDate = Optional.ofNullable(expectedDeliveryDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public SalesOrder withExpectedDeliveryDate(Optional<? extends String> expectedDeliveryDate) {
        Utils.checkNotNull(expectedDeliveryDate, "expectedDeliveryDate");
        this.expectedDeliveryDate = expectedDeliveryDate;
        return this;
    }

    /**
     * Identifier for the sales order, unique for the company in the accounting platform.
     */
    public SalesOrder withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }
    
    /**
     * Identifier for the sales order, unique for the company in the accounting platform.
     */
    public SalesOrder withId(Optional<? extends String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
     */
    public SalesOrder withInvoicingStatus(SalesOrderInvoiceStatus invoicingStatus) {
        Utils.checkNotNull(invoicingStatus, "invoicingStatus");
        this.invoicingStatus = Optional.ofNullable(invoicingStatus);
        return this;
    }
    
    /**
     * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
     */
    public SalesOrder withInvoicingStatus(Optional<? extends SalesOrderInvoiceStatus> invoicingStatus) {
        Utils.checkNotNull(invoicingStatus, "invoicingStatus");
        this.invoicingStatus = invoicingStatus;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public SalesOrder withIssueDate(String issueDate) {
        Utils.checkNotNull(issueDate, "issueDate");
        this.issueDate = Optional.ofNullable(issueDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public SalesOrder withIssueDate(Optional<? extends String> issueDate) {
        Utils.checkNotNull(issueDate, "issueDate");
        this.issueDate = issueDate;
        return this;
    }

    /**
     * An array of line items.
     */
    public SalesOrder withLineItems(java.util.List<SalesOrderLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = JsonNullable.of(lineItems);
        return this;
    }

    /**
     * An array of line items.
     */
    public SalesOrder withLineItems(JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    public SalesOrder withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }
    
    public SalesOrder withMetadata(Optional<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public SalesOrder withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }
    
    public SalesOrder withModifiedDate(Optional<? extends String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Any additional information associated with the sales order.
     */
    public SalesOrder withNote(String note) {
        Utils.checkNotNull(note, "note");
        this.note = JsonNullable.of(note);
        return this;
    }

    /**
     * Any additional information associated with the sales order.
     */
    public SalesOrder withNote(JsonNullable<? extends String> note) {
        Utils.checkNotNull(note, "note");
        this.note = note;
        return this;
    }

    /**
     * Friendly reference for the sales order, commonly generated by the accounting platform.
     */
    public SalesOrder withSalesOrderNumber(String salesOrderNumber) {
        Utils.checkNotNull(salesOrderNumber, "salesOrderNumber");
        this.salesOrderNumber = JsonNullable.of(salesOrderNumber);
        return this;
    }

    /**
     * Friendly reference for the sales order, commonly generated by the accounting platform.
     */
    public SalesOrder withSalesOrderNumber(JsonNullable<? extends String> salesOrderNumber) {
        Utils.checkNotNull(salesOrderNumber, "salesOrderNumber");
        this.salesOrderNumber = salesOrderNumber;
        return this;
    }

    /**
     * Delivery details for any goods that have been ordered.
     */
    public SalesOrder withShipTo(SalesOrderShipTo shipTo) {
        Utils.checkNotNull(shipTo, "shipTo");
        this.shipTo = Optional.ofNullable(shipTo);
        return this;
    }
    
    /**
     * Delivery details for any goods that have been ordered.
     */
    public SalesOrder withShipTo(Optional<? extends SalesOrderShipTo> shipTo) {
        Utils.checkNotNull(shipTo, "shipTo");
        this.shipTo = shipTo;
        return this;
    }

    public SalesOrder withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }
    
    public SalesOrder withSourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * Current state of the sales order.
     */
    public SalesOrder withStatus(SalesOrderStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }
    
    /**
     * Current state of the sales order.
     */
    public SalesOrder withStatus(Optional<? extends SalesOrderStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Total amount of the sales order, including discounts but excluding tax.
     */
    public SalesOrder withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = Optional.ofNullable(subTotal);
        return this;
    }
    
    /**
     * Total amount of the sales order, including discounts but excluding tax.
     */
    public SalesOrder withSubTotal(Optional<? extends Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Total amount of the sales order, including discounts and tax.
     */
    public SalesOrder withTotalAmount(double totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = Optional.ofNullable(totalAmount);
        return this;
    }
    
    /**
     * Total amount of the sales order, including discounts and tax.
     */
    public SalesOrder withTotalAmount(Optional<? extends Double> totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * Total value of any discounts applied to the sales order.
     */
    public SalesOrder withTotalDiscount(double totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = Optional.ofNullable(totalDiscount);
        return this;
    }
    
    /**
     * Total value of any discounts applied to the sales order.
     */
    public SalesOrder withTotalDiscount(Optional<? extends Double> totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = totalDiscount;
        return this;
    }

    /**
     * Total amount of tax included in the sales order.
     */
    public SalesOrder withTotalTaxAmount(double totalTaxAmount) {
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.totalTaxAmount = Optional.ofNullable(totalTaxAmount);
        return this;
    }
    
    /**
     * Total amount of tax included in the sales order.
     */
    public SalesOrder withTotalTaxAmount(Optional<? extends Double> totalTaxAmount) {
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.totalTaxAmount = totalTaxAmount;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        SalesOrder other = (SalesOrder) o;
        return 
            java.util.Objects.deepEquals(this.currency, other.currency) &&
            java.util.Objects.deepEquals(this.currencyRate, other.currencyRate) &&
            java.util.Objects.deepEquals(this.customerPurchaseOrderNumber, other.customerPurchaseOrderNumber) &&
            java.util.Objects.deepEquals(this.customerRef, other.customerRef) &&
            java.util.Objects.deepEquals(this.expectedDeliveryDate, other.expectedDeliveryDate) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.invoicingStatus, other.invoicingStatus) &&
            java.util.Objects.deepEquals(this.issueDate, other.issueDate) &&
            java.util.Objects.deepEquals(this.lineItems, other.lineItems) &&
            java.util.Objects.deepEquals(this.metadata, other.metadata) &&
            java.util.Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            java.util.Objects.deepEquals(this.note, other.note) &&
            java.util.Objects.deepEquals(this.salesOrderNumber, other.salesOrderNumber) &&
            java.util.Objects.deepEquals(this.shipTo, other.shipTo) &&
            java.util.Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            java.util.Objects.deepEquals(this.status, other.status) &&
            java.util.Objects.deepEquals(this.subTotal, other.subTotal) &&
            java.util.Objects.deepEquals(this.totalAmount, other.totalAmount) &&
            java.util.Objects.deepEquals(this.totalDiscount, other.totalDiscount) &&
            java.util.Objects.deepEquals(this.totalTaxAmount, other.totalTaxAmount);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            currency,
            currencyRate,
            customerPurchaseOrderNumber,
            customerRef,
            expectedDeliveryDate,
            id,
            invoicingStatus,
            issueDate,
            lineItems,
            metadata,
            modifiedDate,
            note,
            salesOrderNumber,
            shipTo,
            sourceModifiedDate,
            status,
            subTotal,
            totalAmount,
            totalDiscount,
            totalTaxAmount);
    }
    
    @Override
    public String toString() {
        return Utils.toString(SalesOrder.class,
                "currency", currency,
                "currencyRate", currencyRate,
                "customerPurchaseOrderNumber", customerPurchaseOrderNumber,
                "customerRef", customerRef,
                "expectedDeliveryDate", expectedDeliveryDate,
                "id", id,
                "invoicingStatus", invoicingStatus,
                "issueDate", issueDate,
                "lineItems", lineItems,
                "metadata", metadata,
                "modifiedDate", modifiedDate,
                "note", note,
                "salesOrderNumber", salesOrderNumber,
                "shipTo", shipTo,
                "sourceModifiedDate", sourceModifiedDate,
                "status", status,
                "subTotal", subTotal,
                "totalAmount", totalAmount,
                "totalDiscount", totalDiscount,
                "totalTaxAmount", totalTaxAmount);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> currency = Optional.empty();
 
        private JsonNullable<? extends Double> currencyRate = JsonNullable.undefined();
 
        private JsonNullable<? extends String> customerPurchaseOrderNumber = JsonNullable.undefined();
 
        private Optional<? extends AccountingCustomerRef> customerRef = Optional.empty();
 
        private Optional<? extends String> expectedDeliveryDate = Optional.empty();
 
        private Optional<? extends String> id = Optional.empty();
 
        private Optional<? extends SalesOrderInvoiceStatus> invoicingStatus = Optional.empty();
 
        private Optional<? extends String> issueDate = Optional.empty();
 
        private JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems = JsonNullable.undefined();
 
        private Optional<? extends Metadata> metadata = Optional.empty();
 
        private Optional<? extends String> modifiedDate = Optional.empty();
 
        private JsonNullable<? extends String> note = JsonNullable.undefined();
 
        private JsonNullable<? extends String> salesOrderNumber = JsonNullable.undefined();
 
        private Optional<? extends SalesOrderShipTo> shipTo = Optional.empty();
 
        private Optional<? extends String> sourceModifiedDate = Optional.empty();
 
        private Optional<? extends SalesOrderStatus> status = Optional.empty();
 
        private Optional<? extends Double> subTotal = Optional.empty();
 
        private Optional<? extends Double> totalAmount = Optional.empty();
 
        private Optional<? extends Double> totalDiscount = Optional.empty();
 
        private Optional<? extends Double> totalTaxAmount = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }
        
        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(Optional<? extends String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
         * 
         * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
         * 
         * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
         * 
         * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
         * 
         * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
         * 
         * ## Examples with base currency of GBP
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **USD**          | $20            | 0.781         | £15.62                     |
         * | **EUR**          | €20            | 0.885         | £17.70                     |
         * | **RUB**          | ₽20            | 0.011         | £0.22                      |
         * 
         * ## Examples with base currency of USD
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **GBP**          | £20            | 1.277         | $25.54                     |
         * | **EUR**          | €20            | 1.134         | $22.68                     |
         * | **RUB**          | ₽20            | 0.015         | $0.30                      |
         * 
         * 
         * ### Integration-specific details
         * 
         * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
         * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
         * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
         * 
         * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
         * 
         * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
         * 
         * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
         * 
         * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
         * 
         * ## Examples with base currency of GBP
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **USD**          | $20            | 0.781         | £15.62                     |
         * | **EUR**          | €20            | 0.885         | £17.70                     |
         * | **RUB**          | ₽20            | 0.011         | £0.22                      |
         * 
         * ## Examples with base currency of USD
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **GBP**          | £20            | 1.277         | $25.54                     |
         * | **EUR**          | €20            | 1.134         | $22.68                     |
         * | **RUB**          | ₽20            | 0.015         | $0.30                      |
         * 
         * 
         * ### Integration-specific details
         * 
         * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
         * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
         * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
         */
        public Builder currencyRate(JsonNullable<? extends Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }

        /**
         * A customer-supplied identifier for the purchase order in the customer's system.
         */
        public Builder customerPurchaseOrderNumber(String customerPurchaseOrderNumber) {
            Utils.checkNotNull(customerPurchaseOrderNumber, "customerPurchaseOrderNumber");
            this.customerPurchaseOrderNumber = JsonNullable.of(customerPurchaseOrderNumber);
            return this;
        }

        /**
         * A customer-supplied identifier for the purchase order in the customer's system.
         */
        public Builder customerPurchaseOrderNumber(JsonNullable<? extends String> customerPurchaseOrderNumber) {
            Utils.checkNotNull(customerPurchaseOrderNumber, "customerPurchaseOrderNumber");
            this.customerPurchaseOrderNumber = customerPurchaseOrderNumber;
            return this;
        }

        public Builder customerRef(AccountingCustomerRef customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = Optional.ofNullable(customerRef);
            return this;
        }
        
        public Builder customerRef(Optional<? extends AccountingCustomerRef> customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = customerRef;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder expectedDeliveryDate(String expectedDeliveryDate) {
            Utils.checkNotNull(expectedDeliveryDate, "expectedDeliveryDate");
            this.expectedDeliveryDate = Optional.ofNullable(expectedDeliveryDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder expectedDeliveryDate(Optional<? extends String> expectedDeliveryDate) {
            Utils.checkNotNull(expectedDeliveryDate, "expectedDeliveryDate");
            this.expectedDeliveryDate = expectedDeliveryDate;
            return this;
        }

        /**
         * Identifier for the sales order, unique for the company in the accounting platform.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }
        
        /**
         * Identifier for the sales order, unique for the company in the accounting platform.
         */
        public Builder id(Optional<? extends String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
         */
        public Builder invoicingStatus(SalesOrderInvoiceStatus invoicingStatus) {
            Utils.checkNotNull(invoicingStatus, "invoicingStatus");
            this.invoicingStatus = Optional.ofNullable(invoicingStatus);
            return this;
        }
        
        /**
         * If the sales order is converted to an invoice, or will be in future, the invoicingStatus field indicates the current stage of the invoicing process.
         */
        public Builder invoicingStatus(Optional<? extends SalesOrderInvoiceStatus> invoicingStatus) {
            Utils.checkNotNull(invoicingStatus, "invoicingStatus");
            this.invoicingStatus = invoicingStatus;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder issueDate(String issueDate) {
            Utils.checkNotNull(issueDate, "issueDate");
            this.issueDate = Optional.ofNullable(issueDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder issueDate(Optional<? extends String> issueDate) {
            Utils.checkNotNull(issueDate, "issueDate");
            this.issueDate = issueDate;
            return this;
        }

        /**
         * An array of line items.
         */
        public Builder lineItems(java.util.List<SalesOrderLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = JsonNullable.of(lineItems);
            return this;
        }

        /**
         * An array of line items.
         */
        public Builder lineItems(JsonNullable<? extends java.util.List<SalesOrderLineItem>> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }

        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }
        
        public Builder metadata(Optional<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }
        
        public Builder modifiedDate(Optional<? extends String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Any additional information associated with the sales order.
         */
        public Builder note(String note) {
            Utils.checkNotNull(note, "note");
            this.note = JsonNullable.of(note);
            return this;
        }

        /**
         * Any additional information associated with the sales order.
         */
        public Builder note(JsonNullable<? extends String> note) {
            Utils.checkNotNull(note, "note");
            this.note = note;
            return this;
        }

        /**
         * Friendly reference for the sales order, commonly generated by the accounting platform.
         */
        public Builder salesOrderNumber(String salesOrderNumber) {
            Utils.checkNotNull(salesOrderNumber, "salesOrderNumber");
            this.salesOrderNumber = JsonNullable.of(salesOrderNumber);
            return this;
        }

        /**
         * Friendly reference for the sales order, commonly generated by the accounting platform.
         */
        public Builder salesOrderNumber(JsonNullable<? extends String> salesOrderNumber) {
            Utils.checkNotNull(salesOrderNumber, "salesOrderNumber");
            this.salesOrderNumber = salesOrderNumber;
            return this;
        }

        /**
         * Delivery details for any goods that have been ordered.
         */
        public Builder shipTo(SalesOrderShipTo shipTo) {
            Utils.checkNotNull(shipTo, "shipTo");
            this.shipTo = Optional.ofNullable(shipTo);
            return this;
        }
        
        /**
         * Delivery details for any goods that have been ordered.
         */
        public Builder shipTo(Optional<? extends SalesOrderShipTo> shipTo) {
            Utils.checkNotNull(shipTo, "shipTo");
            this.shipTo = shipTo;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }
        
        public Builder sourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * Current state of the sales order.
         */
        public Builder status(SalesOrderStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }
        
        /**
         * Current state of the sales order.
         */
        public Builder status(Optional<? extends SalesOrderStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Total amount of the sales order, including discounts but excluding tax.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = Optional.ofNullable(subTotal);
            return this;
        }
        
        /**
         * Total amount of the sales order, including discounts but excluding tax.
         */
        public Builder subTotal(Optional<? extends Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }

        /**
         * Total amount of the sales order, including discounts and tax.
         */
        public Builder totalAmount(double totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = Optional.ofNullable(totalAmount);
            return this;
        }
        
        /**
         * Total amount of the sales order, including discounts and tax.
         */
        public Builder totalAmount(Optional<? extends Double> totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }

        /**
         * Total value of any discounts applied to the sales order.
         */
        public Builder totalDiscount(double totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = Optional.ofNullable(totalDiscount);
            return this;
        }
        
        /**
         * Total value of any discounts applied to the sales order.
         */
        public Builder totalDiscount(Optional<? extends Double> totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = totalDiscount;
            return this;
        }

        /**
         * Total amount of tax included in the sales order.
         */
        public Builder totalTaxAmount(double totalTaxAmount) {
            Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
            this.totalTaxAmount = Optional.ofNullable(totalTaxAmount);
            return this;
        }
        
        /**
         * Total amount of tax included in the sales order.
         */
        public Builder totalTaxAmount(Optional<? extends Double> totalTaxAmount) {
            Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
            this.totalTaxAmount = totalTaxAmount;
            return this;
        }
        
        public SalesOrder build() {
            return new SalesOrder(
                currency,
                currencyRate,
                customerPurchaseOrderNumber,
                customerRef,
                expectedDeliveryDate,
                id,
                invoicingStatus,
                issueDate,
                lineItems,
                metadata,
                modifiedDate,
                note,
                salesOrderNumber,
                shipTo,
                sourceModifiedDate,
                status,
                subTotal,
                totalAmount,
                totalDiscount,
                totalTaxAmount);
        }
    }
}

