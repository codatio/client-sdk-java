/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.accounting.models.components;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.accounting.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * UpdateInvoiceResponseAccountingInvoice - &gt; **Invoices or bills?**
 * &gt;
 * &gt; We distinguish between invoices where the company *owes money* vs. *is owed money*. If the company issued an invoice, and is owed money (accounts receivable) we call this an Invoice.
 * &gt;
 * &gt; See [Bills](https://docs.codat.io/accounting-api#/schemas/Bill) for the accounts payable equivalent of bills.
 * 
 * View the coverage for invoices in the &lt;a className="external" href="https://knowledge.codat.io/supported-features/accounting?view=tab-by-data-type&amp;dataType=invoices" target="_blank"&gt;Data coverage explorer&lt;/a&gt;.
 * 
 * ## Overview
 * 
 * An invoice is an itemized record of goods sold or services provided to a [customer](https://docs.codat.io/accounting-api#/schemas/Customer).
 * 
 * In Codat, an invoice contains details of:
 * 
 * - The timeline of the invoice—when it was raised, marked as paid, last edited, and so on.
 * - How much the invoice is for, what portion of the invoice is tax or discounts, and what currency the amounts are represented in. 
 * - Who the invoice has been raised to; the _customer_.
 * - The breakdown of what the invoice is for; the _line items_.
 * - Any [payments](https://docs.codat.io/accounting-api#/schemas/Payment) assigned to the invoice; the _payment allocations_.
 * 
 * &gt; **Invoice PDF downloads**  
 * &gt;
 * &gt; You can &lt;a className="external" href="https://docs.codat.io/accounting-api#/operations/get-invoice-pdf" target="_blank"&gt;download a PDF version&lt;/a&gt; of an invoice for supported integrations.
 * &gt; 
 * &gt; The filename will be invoice-{number}.pdf.
 * 
 * &gt; **Referencing an invoice in Sage 50 and ClearBooks**
 * &gt;
 * &gt; In Sage 50 and ClearBooks, you may prefer to use the **invoiceNumber** to identify an invoice rather than the invoice **id**. Each time a draft invoice is submitted or printed, the draft **id** becomes void and a submitted invoice with a new **id** exists in its place. In both platforms, the **invoiceNumber** should remain the same.
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
@Deprecated
public class UpdateInvoiceResponseAccountingInvoice {

    /**
     * Additional tax amount applied to invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("additionalTaxAmount")
    private Optional<? extends Double> additionalTaxAmount;

    /**
     * Percentage rate of any additional tax applied to the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("additionalTaxPercentage")
    private Optional<? extends Double> additionalTaxPercentage;

    /**
     * Amount outstanding on the invoice.
     */
    @JsonProperty("amountDue")
    private double amountDue;

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<? extends String> currency;

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currencyRate")
    private JsonNullable<? extends Double> currencyRate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerRef")
    private Optional<? extends AccountingCustomerRef> customerRef;

    /**
     * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discountPercentage")
    private JsonNullable<? extends Double> discountPercentage;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dueDate")
    private Optional<? extends String> dueDate;

    /**
     * Identifier for the invoice, unique to the company in the accounting platform.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<? extends String> id;

    /**
     * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("invoiceNumber")
    private JsonNullable<? extends String> invoiceNumber;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonProperty("issueDate")
    private String issueDate;

    /**
     * An array of line items.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lineItems")
    private JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends Metadata> metadata;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<? extends String> modifiedDate;

    /**
     * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private JsonNullable<? extends String> note;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paidOnDate")
    private Optional<? extends String> paidOnDate;

    /**
     * An array of payment allocations.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("paymentAllocations")
    private JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations;

    /**
     * List of references to related Sales orders.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("salesOrderRefs")
    private JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<? extends String> sourceModifiedDate;

    /**
     * Current state of the invoice:
     * 
     * - `Draft` - Invoice hasn't been submitted to the supplier. It may be in a pending state or is scheduled for future submission, for example by email.
     * - `Submitted` - Invoice is no longer a draft. It has been processed and, or, sent to the customer. In this state, it will impact the ledger. It also has no payments made against it (amountDue == totalAmount).
     * - `PartiallyPaid` - The balance paid against the invoice is positive, but less than the total invoice amount (0 &lt; amountDue &lt; totalAmount).
     * - `Paid` - Invoice is paid in full. This includes if the invoice has been credited or overpaid (amountDue == 0).
     * - `Void` - An invoice can become Void when it's deleted, refunded, written off, or cancelled. A voided invoice may still be PartiallyPaid, and so all outstanding amounts on voided invoices are removed from the accounts receivable account.
     */
    @JsonProperty("status")
    private InvoiceStatus status;

    /**
     * Total amount of the invoice excluding any taxes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subTotal")
    private JsonNullable<? extends Double> subTotal;

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplementalData")
    private Optional<? extends SupplementalData> supplementalData;

    /**
     * Amount of the invoice, inclusive of tax.
     */
    @JsonProperty("totalAmount")
    private double totalAmount;

    /**
     * Numerical value of discounts applied to the invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalDiscount")
    private JsonNullable<? extends Double> totalDiscount;

    /**
     * Amount of tax on the invoice.
     */
    @JsonProperty("totalTaxAmount")
    private double totalTaxAmount;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("withholdingTax")
    private JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax;

    public UpdateInvoiceResponseAccountingInvoice(
            @JsonProperty("additionalTaxAmount") Optional<? extends Double> additionalTaxAmount,
            @JsonProperty("additionalTaxPercentage") Optional<? extends Double> additionalTaxPercentage,
            @JsonProperty("amountDue") double amountDue,
            @JsonProperty("currency") Optional<? extends String> currency,
            @JsonProperty("currencyRate") JsonNullable<? extends Double> currencyRate,
            @JsonProperty("customerRef") Optional<? extends AccountingCustomerRef> customerRef,
            @JsonProperty("discountPercentage") JsonNullable<? extends Double> discountPercentage,
            @JsonProperty("dueDate") Optional<? extends String> dueDate,
            @JsonProperty("id") Optional<? extends String> id,
            @JsonProperty("invoiceNumber") JsonNullable<? extends String> invoiceNumber,
            @JsonProperty("issueDate") String issueDate,
            @JsonProperty("lineItems") JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems,
            @JsonProperty("metadata") Optional<? extends Metadata> metadata,
            @JsonProperty("modifiedDate") Optional<? extends String> modifiedDate,
            @JsonProperty("note") JsonNullable<? extends String> note,
            @JsonProperty("paidOnDate") Optional<? extends String> paidOnDate,
            @JsonProperty("paymentAllocations") JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations,
            @JsonProperty("salesOrderRefs") JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs,
            @JsonProperty("sourceModifiedDate") Optional<? extends String> sourceModifiedDate,
            @JsonProperty("status") InvoiceStatus status,
            @JsonProperty("subTotal") JsonNullable<? extends Double> subTotal,
            @JsonProperty("supplementalData") Optional<? extends SupplementalData> supplementalData,
            @JsonProperty("totalAmount") double totalAmount,
            @JsonProperty("totalDiscount") JsonNullable<? extends Double> totalDiscount,
            @JsonProperty("totalTaxAmount") double totalTaxAmount,
            @JsonProperty("withholdingTax") JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax) {
        Utils.checkNotNull(additionalTaxAmount, "additionalTaxAmount");
        Utils.checkNotNull(additionalTaxPercentage, "additionalTaxPercentage");
        Utils.checkNotNull(amountDue, "amountDue");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(customerRef, "customerRef");
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(invoiceNumber, "invoiceNumber");
        Utils.checkNotNull(issueDate, "issueDate");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(note, "note");
        Utils.checkNotNull(paidOnDate, "paidOnDate");
        Utils.checkNotNull(paymentAllocations, "paymentAllocations");
        Utils.checkNotNull(salesOrderRefs, "salesOrderRefs");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(supplementalData, "supplementalData");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        Utils.checkNotNull(withholdingTax, "withholdingTax");
        this.additionalTaxAmount = additionalTaxAmount;
        this.additionalTaxPercentage = additionalTaxPercentage;
        this.amountDue = amountDue;
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.customerRef = customerRef;
        this.discountPercentage = discountPercentage;
        this.dueDate = dueDate;
        this.id = id;
        this.invoiceNumber = invoiceNumber;
        this.issueDate = issueDate;
        this.lineItems = lineItems;
        this.metadata = metadata;
        this.modifiedDate = modifiedDate;
        this.note = note;
        this.paidOnDate = paidOnDate;
        this.paymentAllocations = paymentAllocations;
        this.salesOrderRefs = salesOrderRefs;
        this.sourceModifiedDate = sourceModifiedDate;
        this.status = status;
        this.subTotal = subTotal;
        this.supplementalData = supplementalData;
        this.totalAmount = totalAmount;
        this.totalDiscount = totalDiscount;
        this.totalTaxAmount = totalTaxAmount;
        this.withholdingTax = withholdingTax;
    }

    /**
     * Additional tax amount applied to invoice.
     */
    public Optional<? extends Double> additionalTaxAmount() {
        return additionalTaxAmount;
    }

    /**
     * Percentage rate of any additional tax applied to the invoice.
     */
    public Optional<? extends Double> additionalTaxPercentage() {
        return additionalTaxPercentage;
    }

    /**
     * Amount outstanding on the invoice.
     */
    public double amountDue() {
        return amountDue;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public Optional<? extends String> currency() {
        return currency;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public JsonNullable<? extends Double> currencyRate() {
        return currencyRate;
    }

    public Optional<? extends AccountingCustomerRef> customerRef() {
        return customerRef;
    }

    /**
     * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
     */
    public JsonNullable<? extends Double> discountPercentage() {
        return discountPercentage;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> dueDate() {
        return dueDate;
    }

    /**
     * Identifier for the invoice, unique to the company in the accounting platform.
     */
    public Optional<? extends String> id() {
        return id;
    }

    /**
     * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
     */
    public JsonNullable<? extends String> invoiceNumber() {
        return invoiceNumber;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public String issueDate() {
        return issueDate;
    }

    /**
     * An array of line items.
     */
    public JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems() {
        return lineItems;
    }

    public Optional<? extends Metadata> metadata() {
        return metadata;
    }

    public Optional<? extends String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
     */
    public JsonNullable<? extends String> note() {
        return note;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> paidOnDate() {
        return paidOnDate;
    }

    /**
     * An array of payment allocations.
     */
    public JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations() {
        return paymentAllocations;
    }

    /**
     * List of references to related Sales orders.
     */
    public JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs() {
        return salesOrderRefs;
    }

    public Optional<? extends String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * Current state of the invoice:
     * 
     * - `Draft` - Invoice hasn't been submitted to the supplier. It may be in a pending state or is scheduled for future submission, for example by email.
     * - `Submitted` - Invoice is no longer a draft. It has been processed and, or, sent to the customer. In this state, it will impact the ledger. It also has no payments made against it (amountDue == totalAmount).
     * - `PartiallyPaid` - The balance paid against the invoice is positive, but less than the total invoice amount (0 &lt; amountDue &lt; totalAmount).
     * - `Paid` - Invoice is paid in full. This includes if the invoice has been credited or overpaid (amountDue == 0).
     * - `Void` - An invoice can become Void when it's deleted, refunded, written off, or cancelled. A voided invoice may still be PartiallyPaid, and so all outstanding amounts on voided invoices are removed from the accounts receivable account.
     */
    public InvoiceStatus status() {
        return status;
    }

    /**
     * Total amount of the invoice excluding any taxes.
     */
    public JsonNullable<? extends Double> subTotal() {
        return subTotal;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public Optional<? extends SupplementalData> supplementalData() {
        return supplementalData;
    }

    /**
     * Amount of the invoice, inclusive of tax.
     */
    public double totalAmount() {
        return totalAmount;
    }

    /**
     * Numerical value of discounts applied to the invoice.
     */
    public JsonNullable<? extends Double> totalDiscount() {
        return totalDiscount;
    }

    /**
     * Amount of tax on the invoice.
     */
    public double totalTaxAmount() {
        return totalTaxAmount;
    }

    public JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax() {
        return withholdingTax;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Additional tax amount applied to invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withAdditionalTaxAmount(double additionalTaxAmount) {
        Utils.checkNotNull(additionalTaxAmount, "additionalTaxAmount");
        this.additionalTaxAmount = Optional.ofNullable(additionalTaxAmount);
        return this;
    }
    
    /**
     * Additional tax amount applied to invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withAdditionalTaxAmount(Optional<? extends Double> additionalTaxAmount) {
        Utils.checkNotNull(additionalTaxAmount, "additionalTaxAmount");
        this.additionalTaxAmount = additionalTaxAmount;
        return this;
    }

    /**
     * Percentage rate of any additional tax applied to the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withAdditionalTaxPercentage(double additionalTaxPercentage) {
        Utils.checkNotNull(additionalTaxPercentage, "additionalTaxPercentage");
        this.additionalTaxPercentage = Optional.ofNullable(additionalTaxPercentage);
        return this;
    }
    
    /**
     * Percentage rate of any additional tax applied to the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withAdditionalTaxPercentage(Optional<? extends Double> additionalTaxPercentage) {
        Utils.checkNotNull(additionalTaxPercentage, "additionalTaxPercentage");
        this.additionalTaxPercentage = additionalTaxPercentage;
        return this;
    }

    /**
     * Amount outstanding on the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withAmountDue(double amountDue) {
        Utils.checkNotNull(amountDue, "amountDue");
        this.amountDue = amountDue;
        return this;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public UpdateInvoiceResponseAccountingInvoice withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }
    
    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public UpdateInvoiceResponseAccountingInvoice withCurrency(Optional<? extends String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public UpdateInvoiceResponseAccountingInvoice withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
     * 
     * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
     * 
     * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
     * 
     * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
     * 
     * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
     * 
     * ## Examples with base currency of GBP
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **USD**          | $20            | 0.781         | £15.62                     |
     * | **EUR**          | €20            | 0.885         | £17.70                     |
     * | **RUB**          | ₽20            | 0.011         | £0.22                      |
     * 
     * ## Examples with base currency of USD
     * 
     * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
     * | :--------------- | :------------- | :------------ | :------------------------- |
     * | **GBP**          | £20            | 1.277         | $25.54                     |
     * | **EUR**          | €20            | 1.134         | $22.68                     |
     * | **RUB**          | ₽20            | 0.015         | $0.30                      |
     * 
     * 
     * ### Integration-specific details
     * 
     * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
     * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
     * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
     */
    public UpdateInvoiceResponseAccountingInvoice withCurrencyRate(JsonNullable<? extends Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withCustomerRef(AccountingCustomerRef customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = Optional.ofNullable(customerRef);
        return this;
    }
    
    public UpdateInvoiceResponseAccountingInvoice withCustomerRef(Optional<? extends AccountingCustomerRef> customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = customerRef;
        return this;
    }

    /**
     * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
     */
    public UpdateInvoiceResponseAccountingInvoice withDiscountPercentage(double discountPercentage) {
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        this.discountPercentage = JsonNullable.of(discountPercentage);
        return this;
    }

    /**
     * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
     */
    public UpdateInvoiceResponseAccountingInvoice withDiscountPercentage(JsonNullable<? extends Double> discountPercentage) {
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        this.discountPercentage = discountPercentage;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public UpdateInvoiceResponseAccountingInvoice withDueDate(String dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = Optional.ofNullable(dueDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public UpdateInvoiceResponseAccountingInvoice withDueDate(Optional<? extends String> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Identifier for the invoice, unique to the company in the accounting platform.
     */
    public UpdateInvoiceResponseAccountingInvoice withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }
    
    /**
     * Identifier for the invoice, unique to the company in the accounting platform.
     */
    public UpdateInvoiceResponseAccountingInvoice withId(Optional<? extends String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
     */
    public UpdateInvoiceResponseAccountingInvoice withInvoiceNumber(String invoiceNumber) {
        Utils.checkNotNull(invoiceNumber, "invoiceNumber");
        this.invoiceNumber = JsonNullable.of(invoiceNumber);
        return this;
    }

    /**
     * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
     */
    public UpdateInvoiceResponseAccountingInvoice withInvoiceNumber(JsonNullable<? extends String> invoiceNumber) {
        Utils.checkNotNull(invoiceNumber, "invoiceNumber");
        this.invoiceNumber = invoiceNumber;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public UpdateInvoiceResponseAccountingInvoice withIssueDate(String issueDate) {
        Utils.checkNotNull(issueDate, "issueDate");
        this.issueDate = issueDate;
        return this;
    }

    /**
     * An array of line items.
     */
    public UpdateInvoiceResponseAccountingInvoice withLineItems(java.util.List<InvoiceLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = JsonNullable.of(lineItems);
        return this;
    }

    /**
     * An array of line items.
     */
    public UpdateInvoiceResponseAccountingInvoice withLineItems(JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }
    
    public UpdateInvoiceResponseAccountingInvoice withMetadata(Optional<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }
    
    public UpdateInvoiceResponseAccountingInvoice withModifiedDate(Optional<? extends String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
     */
    public UpdateInvoiceResponseAccountingInvoice withNote(String note) {
        Utils.checkNotNull(note, "note");
        this.note = JsonNullable.of(note);
        return this;
    }

    /**
     * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
     */
    public UpdateInvoiceResponseAccountingInvoice withNote(JsonNullable<? extends String> note) {
        Utils.checkNotNull(note, "note");
        this.note = note;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public UpdateInvoiceResponseAccountingInvoice withPaidOnDate(String paidOnDate) {
        Utils.checkNotNull(paidOnDate, "paidOnDate");
        this.paidOnDate = Optional.ofNullable(paidOnDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public UpdateInvoiceResponseAccountingInvoice withPaidOnDate(Optional<? extends String> paidOnDate) {
        Utils.checkNotNull(paidOnDate, "paidOnDate");
        this.paidOnDate = paidOnDate;
        return this;
    }

    /**
     * An array of payment allocations.
     */
    public UpdateInvoiceResponseAccountingInvoice withPaymentAllocations(java.util.List<PaymentAllocationItems> paymentAllocations) {
        Utils.checkNotNull(paymentAllocations, "paymentAllocations");
        this.paymentAllocations = JsonNullable.of(paymentAllocations);
        return this;
    }

    /**
     * An array of payment allocations.
     */
    public UpdateInvoiceResponseAccountingInvoice withPaymentAllocations(JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations) {
        Utils.checkNotNull(paymentAllocations, "paymentAllocations");
        this.paymentAllocations = paymentAllocations;
        return this;
    }

    /**
     * List of references to related Sales orders.
     */
    public UpdateInvoiceResponseAccountingInvoice withSalesOrderRefs(java.util.List<SalesOrderRef> salesOrderRefs) {
        Utils.checkNotNull(salesOrderRefs, "salesOrderRefs");
        this.salesOrderRefs = JsonNullable.of(salesOrderRefs);
        return this;
    }

    /**
     * List of references to related Sales orders.
     */
    public UpdateInvoiceResponseAccountingInvoice withSalesOrderRefs(JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs) {
        Utils.checkNotNull(salesOrderRefs, "salesOrderRefs");
        this.salesOrderRefs = salesOrderRefs;
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }
    
    public UpdateInvoiceResponseAccountingInvoice withSourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * Current state of the invoice:
     * 
     * - `Draft` - Invoice hasn't been submitted to the supplier. It may be in a pending state or is scheduled for future submission, for example by email.
     * - `Submitted` - Invoice is no longer a draft. It has been processed and, or, sent to the customer. In this state, it will impact the ledger. It also has no payments made against it (amountDue == totalAmount).
     * - `PartiallyPaid` - The balance paid against the invoice is positive, but less than the total invoice amount (0 &lt; amountDue &lt; totalAmount).
     * - `Paid` - Invoice is paid in full. This includes if the invoice has been credited or overpaid (amountDue == 0).
     * - `Void` - An invoice can become Void when it's deleted, refunded, written off, or cancelled. A voided invoice may still be PartiallyPaid, and so all outstanding amounts on voided invoices are removed from the accounts receivable account.
     */
    public UpdateInvoiceResponseAccountingInvoice withStatus(InvoiceStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Total amount of the invoice excluding any taxes.
     */
    public UpdateInvoiceResponseAccountingInvoice withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }

    /**
     * Total amount of the invoice excluding any taxes.
     */
    public UpdateInvoiceResponseAccountingInvoice withSubTotal(JsonNullable<? extends Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public UpdateInvoiceResponseAccountingInvoice withSupplementalData(SupplementalData supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = Optional.ofNullable(supplementalData);
        return this;
    }
    
    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public UpdateInvoiceResponseAccountingInvoice withSupplementalData(Optional<? extends SupplementalData> supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = supplementalData;
        return this;
    }

    /**
     * Amount of the invoice, inclusive of tax.
     */
    public UpdateInvoiceResponseAccountingInvoice withTotalAmount(double totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * Numerical value of discounts applied to the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withTotalDiscount(double totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = JsonNullable.of(totalDiscount);
        return this;
    }

    /**
     * Numerical value of discounts applied to the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withTotalDiscount(JsonNullable<? extends Double> totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = totalDiscount;
        return this;
    }

    /**
     * Amount of tax on the invoice.
     */
    public UpdateInvoiceResponseAccountingInvoice withTotalTaxAmount(double totalTaxAmount) {
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.totalTaxAmount = totalTaxAmount;
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withWithholdingTax(java.util.List<WithholdingTaxItems> withholdingTax) {
        Utils.checkNotNull(withholdingTax, "withholdingTax");
        this.withholdingTax = JsonNullable.of(withholdingTax);
        return this;
    }

    public UpdateInvoiceResponseAccountingInvoice withWithholdingTax(JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax) {
        Utils.checkNotNull(withholdingTax, "withholdingTax");
        this.withholdingTax = withholdingTax;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UpdateInvoiceResponseAccountingInvoice other = (UpdateInvoiceResponseAccountingInvoice) o;
        return 
            java.util.Objects.deepEquals(this.additionalTaxAmount, other.additionalTaxAmount) &&
            java.util.Objects.deepEquals(this.additionalTaxPercentage, other.additionalTaxPercentage) &&
            java.util.Objects.deepEquals(this.amountDue, other.amountDue) &&
            java.util.Objects.deepEquals(this.currency, other.currency) &&
            java.util.Objects.deepEquals(this.currencyRate, other.currencyRate) &&
            java.util.Objects.deepEquals(this.customerRef, other.customerRef) &&
            java.util.Objects.deepEquals(this.discountPercentage, other.discountPercentage) &&
            java.util.Objects.deepEquals(this.dueDate, other.dueDate) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.invoiceNumber, other.invoiceNumber) &&
            java.util.Objects.deepEquals(this.issueDate, other.issueDate) &&
            java.util.Objects.deepEquals(this.lineItems, other.lineItems) &&
            java.util.Objects.deepEquals(this.metadata, other.metadata) &&
            java.util.Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            java.util.Objects.deepEquals(this.note, other.note) &&
            java.util.Objects.deepEquals(this.paidOnDate, other.paidOnDate) &&
            java.util.Objects.deepEquals(this.paymentAllocations, other.paymentAllocations) &&
            java.util.Objects.deepEquals(this.salesOrderRefs, other.salesOrderRefs) &&
            java.util.Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            java.util.Objects.deepEquals(this.status, other.status) &&
            java.util.Objects.deepEquals(this.subTotal, other.subTotal) &&
            java.util.Objects.deepEquals(this.supplementalData, other.supplementalData) &&
            java.util.Objects.deepEquals(this.totalAmount, other.totalAmount) &&
            java.util.Objects.deepEquals(this.totalDiscount, other.totalDiscount) &&
            java.util.Objects.deepEquals(this.totalTaxAmount, other.totalTaxAmount) &&
            java.util.Objects.deepEquals(this.withholdingTax, other.withholdingTax);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            additionalTaxAmount,
            additionalTaxPercentage,
            amountDue,
            currency,
            currencyRate,
            customerRef,
            discountPercentage,
            dueDate,
            id,
            invoiceNumber,
            issueDate,
            lineItems,
            metadata,
            modifiedDate,
            note,
            paidOnDate,
            paymentAllocations,
            salesOrderRefs,
            sourceModifiedDate,
            status,
            subTotal,
            supplementalData,
            totalAmount,
            totalDiscount,
            totalTaxAmount,
            withholdingTax);
    }
    
    @Override
    public String toString() {
        return Utils.toString(UpdateInvoiceResponseAccountingInvoice.class,
                "additionalTaxAmount", additionalTaxAmount,
                "additionalTaxPercentage", additionalTaxPercentage,
                "amountDue", amountDue,
                "currency", currency,
                "currencyRate", currencyRate,
                "customerRef", customerRef,
                "discountPercentage", discountPercentage,
                "dueDate", dueDate,
                "id", id,
                "invoiceNumber", invoiceNumber,
                "issueDate", issueDate,
                "lineItems", lineItems,
                "metadata", metadata,
                "modifiedDate", modifiedDate,
                "note", note,
                "paidOnDate", paidOnDate,
                "paymentAllocations", paymentAllocations,
                "salesOrderRefs", salesOrderRefs,
                "sourceModifiedDate", sourceModifiedDate,
                "status", status,
                "subTotal", subTotal,
                "supplementalData", supplementalData,
                "totalAmount", totalAmount,
                "totalDiscount", totalDiscount,
                "totalTaxAmount", totalTaxAmount,
                "withholdingTax", withholdingTax);
    }
    
    public final static class Builder {
 
        private Optional<? extends Double> additionalTaxAmount = Optional.empty();
 
        private Optional<? extends Double> additionalTaxPercentage = Optional.empty();
 
        private Double amountDue;
 
        private Optional<? extends String> currency = Optional.empty();
 
        private JsonNullable<? extends Double> currencyRate = JsonNullable.undefined();
 
        private Optional<? extends AccountingCustomerRef> customerRef = Optional.empty();
 
        private JsonNullable<? extends Double> discountPercentage = JsonNullable.undefined();
 
        private Optional<? extends String> dueDate = Optional.empty();
 
        private Optional<? extends String> id = Optional.empty();
 
        private JsonNullable<? extends String> invoiceNumber = JsonNullable.undefined();
 
        private String issueDate;
 
        private JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems = JsonNullable.undefined();
 
        private Optional<? extends Metadata> metadata = Optional.empty();
 
        private Optional<? extends String> modifiedDate = Optional.empty();
 
        private JsonNullable<? extends String> note = JsonNullable.undefined();
 
        private Optional<? extends String> paidOnDate = Optional.empty();
 
        private JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations = JsonNullable.undefined();
 
        private JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs = JsonNullable.undefined();
 
        private Optional<? extends String> sourceModifiedDate = Optional.empty();
 
        private InvoiceStatus status;
 
        private JsonNullable<? extends Double> subTotal = JsonNullable.undefined();
 
        private Optional<? extends SupplementalData> supplementalData = Optional.empty();
 
        private Double totalAmount;
 
        private JsonNullable<? extends Double> totalDiscount = JsonNullable.undefined();
 
        private Double totalTaxAmount;
 
        private JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Additional tax amount applied to invoice.
         */
        public Builder additionalTaxAmount(double additionalTaxAmount) {
            Utils.checkNotNull(additionalTaxAmount, "additionalTaxAmount");
            this.additionalTaxAmount = Optional.ofNullable(additionalTaxAmount);
            return this;
        }
        
        /**
         * Additional tax amount applied to invoice.
         */
        public Builder additionalTaxAmount(Optional<? extends Double> additionalTaxAmount) {
            Utils.checkNotNull(additionalTaxAmount, "additionalTaxAmount");
            this.additionalTaxAmount = additionalTaxAmount;
            return this;
        }

        /**
         * Percentage rate of any additional tax applied to the invoice.
         */
        public Builder additionalTaxPercentage(double additionalTaxPercentage) {
            Utils.checkNotNull(additionalTaxPercentage, "additionalTaxPercentage");
            this.additionalTaxPercentage = Optional.ofNullable(additionalTaxPercentage);
            return this;
        }
        
        /**
         * Percentage rate of any additional tax applied to the invoice.
         */
        public Builder additionalTaxPercentage(Optional<? extends Double> additionalTaxPercentage) {
            Utils.checkNotNull(additionalTaxPercentage, "additionalTaxPercentage");
            this.additionalTaxPercentage = additionalTaxPercentage;
            return this;
        }

        /**
         * Amount outstanding on the invoice.
         */
        public Builder amountDue(double amountDue) {
            Utils.checkNotNull(amountDue, "amountDue");
            this.amountDue = amountDue;
            return this;
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }
        
        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(Optional<? extends String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
         * 
         * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
         * 
         * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
         * 
         * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
         * 
         * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
         * 
         * ## Examples with base currency of GBP
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **USD**          | $20            | 0.781         | £15.62                     |
         * | **EUR**          | €20            | 0.885         | £17.70                     |
         * | **RUB**          | ₽20            | 0.011         | £0.22                      |
         * 
         * ## Examples with base currency of USD
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **GBP**          | £20            | 1.277         | $25.54                     |
         * | **EUR**          | €20            | 1.134         | $22.68                     |
         * | **RUB**          | ₽20            | 0.015         | $0.30                      |
         * 
         * 
         * ### Integration-specific details
         * 
         * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
         * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
         * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.
         * 
         * Currency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  
         * 
         * It is not possible to perform the currency conversion with two or more non-base currencies participating in the transaction. For example, if a company's base currency is USD, and it has a bill issued in EUR, then the bill payment must happen in USD or EUR.
         * 
         * Where the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). 
         * 
         * For accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.
         * 
         * ## Examples with base currency of GBP
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **USD**          | $20            | 0.781         | £15.62                     |
         * | **EUR**          | €20            | 0.885         | £17.70                     |
         * | **RUB**          | ₽20            | 0.011         | £0.22                      |
         * 
         * ## Examples with base currency of USD
         * 
         * | Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |
         * | :--------------- | :------------- | :------------ | :------------------------- |
         * | **GBP**          | £20            | 1.277         | $25.54                     |
         * | **EUR**          | €20            | 1.134         | $22.68                     |
         * | **RUB**          | ₽20            | 0.015         | $0.30                      |
         * 
         * 
         * ### Integration-specific details
         * 
         * | Integration       | Scenario                                        | System behavior                                                                                                                                                      |
         * |-------------------|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
         * | QuickBooks Online | Transaction currency differs from base currency | If currency rate value is left `null`, a rate of 1 will be used by QBO by default. To override this, include the required currency rate in the expense transaction.  |
         */
        public Builder currencyRate(JsonNullable<? extends Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }

        public Builder customerRef(AccountingCustomerRef customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = Optional.ofNullable(customerRef);
            return this;
        }
        
        public Builder customerRef(Optional<? extends AccountingCustomerRef> customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = customerRef;
            return this;
        }

        /**
         * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
         */
        public Builder discountPercentage(double discountPercentage) {
            Utils.checkNotNull(discountPercentage, "discountPercentage");
            this.discountPercentage = JsonNullable.of(discountPercentage);
            return this;
        }

        /**
         * Percentage rate (from 0 to 100) of discounts applied to the invoice. For example: A 5% discount will return a value of `5`, not `0.05`.
         */
        public Builder discountPercentage(JsonNullable<? extends Double> discountPercentage) {
            Utils.checkNotNull(discountPercentage, "discountPercentage");
            this.discountPercentage = discountPercentage;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder dueDate(String dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = Optional.ofNullable(dueDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder dueDate(Optional<? extends String> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }

        /**
         * Identifier for the invoice, unique to the company in the accounting platform.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }
        
        /**
         * Identifier for the invoice, unique to the company in the accounting platform.
         */
        public Builder id(Optional<? extends String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
         */
        public Builder invoiceNumber(String invoiceNumber) {
            Utils.checkNotNull(invoiceNumber, "invoiceNumber");
            this.invoiceNumber = JsonNullable.of(invoiceNumber);
            return this;
        }

        /**
         * Friendly reference for the invoice. If available, this appears in the file name of invoice attachments.
         */
        public Builder invoiceNumber(JsonNullable<? extends String> invoiceNumber) {
            Utils.checkNotNull(invoiceNumber, "invoiceNumber");
            this.invoiceNumber = invoiceNumber;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder issueDate(String issueDate) {
            Utils.checkNotNull(issueDate, "issueDate");
            this.issueDate = issueDate;
            return this;
        }

        /**
         * An array of line items.
         */
        public Builder lineItems(java.util.List<InvoiceLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = JsonNullable.of(lineItems);
            return this;
        }

        /**
         * An array of line items.
         */
        public Builder lineItems(JsonNullable<? extends java.util.List<InvoiceLineItem>> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }

        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }
        
        public Builder metadata(Optional<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }
        
        public Builder modifiedDate(Optional<? extends String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
         */
        public Builder note(String note) {
            Utils.checkNotNull(note, "note");
            this.note = JsonNullable.of(note);
            return this;
        }

        /**
         * Any additional information about the invoice. Where possible, Codat links to a data field in the accounting platform that is publicly available. This means that the contents of the note field are included when an invoice is emailed from the accounting platform to the customer.
         */
        public Builder note(JsonNullable<? extends String> note) {
            Utils.checkNotNull(note, "note");
            this.note = note;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder paidOnDate(String paidOnDate) {
            Utils.checkNotNull(paidOnDate, "paidOnDate");
            this.paidOnDate = Optional.ofNullable(paidOnDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder paidOnDate(Optional<? extends String> paidOnDate) {
            Utils.checkNotNull(paidOnDate, "paidOnDate");
            this.paidOnDate = paidOnDate;
            return this;
        }

        /**
         * An array of payment allocations.
         */
        public Builder paymentAllocations(java.util.List<PaymentAllocationItems> paymentAllocations) {
            Utils.checkNotNull(paymentAllocations, "paymentAllocations");
            this.paymentAllocations = JsonNullable.of(paymentAllocations);
            return this;
        }

        /**
         * An array of payment allocations.
         */
        public Builder paymentAllocations(JsonNullable<? extends java.util.List<PaymentAllocationItems>> paymentAllocations) {
            Utils.checkNotNull(paymentAllocations, "paymentAllocations");
            this.paymentAllocations = paymentAllocations;
            return this;
        }

        /**
         * List of references to related Sales orders.
         */
        public Builder salesOrderRefs(java.util.List<SalesOrderRef> salesOrderRefs) {
            Utils.checkNotNull(salesOrderRefs, "salesOrderRefs");
            this.salesOrderRefs = JsonNullable.of(salesOrderRefs);
            return this;
        }

        /**
         * List of references to related Sales orders.
         */
        public Builder salesOrderRefs(JsonNullable<? extends java.util.List<SalesOrderRef>> salesOrderRefs) {
            Utils.checkNotNull(salesOrderRefs, "salesOrderRefs");
            this.salesOrderRefs = salesOrderRefs;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }
        
        public Builder sourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * Current state of the invoice:
         * 
         * - `Draft` - Invoice hasn't been submitted to the supplier. It may be in a pending state or is scheduled for future submission, for example by email.
         * - `Submitted` - Invoice is no longer a draft. It has been processed and, or, sent to the customer. In this state, it will impact the ledger. It also has no payments made against it (amountDue == totalAmount).
         * - `PartiallyPaid` - The balance paid against the invoice is positive, but less than the total invoice amount (0 &lt; amountDue &lt; totalAmount).
         * - `Paid` - Invoice is paid in full. This includes if the invoice has been credited or overpaid (amountDue == 0).
         * - `Void` - An invoice can become Void when it's deleted, refunded, written off, or cancelled. A voided invoice may still be PartiallyPaid, and so all outstanding amounts on voided invoices are removed from the accounts receivable account.
         */
        public Builder status(InvoiceStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Total amount of the invoice excluding any taxes.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Total amount of the invoice excluding any taxes.
         */
        public Builder subTotal(JsonNullable<? extends Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(SupplementalData supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = Optional.ofNullable(supplementalData);
            return this;
        }
        
        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(Optional<? extends SupplementalData> supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = supplementalData;
            return this;
        }

        /**
         * Amount of the invoice, inclusive of tax.
         */
        public Builder totalAmount(double totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }

        /**
         * Numerical value of discounts applied to the invoice.
         */
        public Builder totalDiscount(double totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = JsonNullable.of(totalDiscount);
            return this;
        }

        /**
         * Numerical value of discounts applied to the invoice.
         */
        public Builder totalDiscount(JsonNullable<? extends Double> totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = totalDiscount;
            return this;
        }

        /**
         * Amount of tax on the invoice.
         */
        public Builder totalTaxAmount(double totalTaxAmount) {
            Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
            this.totalTaxAmount = totalTaxAmount;
            return this;
        }

        public Builder withholdingTax(java.util.List<WithholdingTaxItems> withholdingTax) {
            Utils.checkNotNull(withholdingTax, "withholdingTax");
            this.withholdingTax = JsonNullable.of(withholdingTax);
            return this;
        }

        public Builder withholdingTax(JsonNullable<? extends java.util.List<WithholdingTaxItems>> withholdingTax) {
            Utils.checkNotNull(withholdingTax, "withholdingTax");
            this.withholdingTax = withholdingTax;
            return this;
        }
        
        public UpdateInvoiceResponseAccountingInvoice build() {
            return new UpdateInvoiceResponseAccountingInvoice(
                additionalTaxAmount,
                additionalTaxPercentage,
                amountDue,
                currency,
                currencyRate,
                customerRef,
                discountPercentage,
                dueDate,
                id,
                invoiceNumber,
                issueDate,
                lineItems,
                metadata,
                modifiedDate,
                note,
                paidOnDate,
                paymentAllocations,
                salesOrderRefs,
                sourceModifiedDate,
                status,
                subTotal,
                supplementalData,
                totalAmount,
                totalDiscount,
                totalTaxAmount,
                withholdingTax);
        }
    }
}

