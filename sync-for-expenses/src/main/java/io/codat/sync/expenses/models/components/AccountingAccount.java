/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.sync.expenses.models.components;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import io.codat.sync.expenses.utils.Utils;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * AccountingAccount - ï»¿&gt; **Language tip:** Accounts are also referred to as **chart of accounts**, **nominal accounts**, and **general ledger**.
 * 
 * View the coverage for accounts in the &lt;a className="external" href="https://knowledge.codat.io/supported-features/accounting?view=tab-by-data-type&amp;dataType=chartOfAccounts" target="_blank"&gt;Data coverage explorer&lt;/a&gt;.
 * 
 * ## Overview
 * 
 * Accounts are the categories a business uses to record accounting transactions. From the Accounts endpoints, you can retrieve a list of all accounts for a specified company.
 * 
 * The categories for an account include:
 * * Asset
 * * Expense
 * * Income
 * * Liability
 * * Equity.
 * 
 * The same account may have a different category based on the integration it is used in. For example, a current account (known as checking in the US) should be categorized as `Asset.Current` for Xero, and `Asset.Bank.Checking` for QuickBooks Online.
 * 
 * At the same time, each integration may have its own requirements to the categories. For example, a Paypal account in Xero is of the `Asset.Bank` category and therefore requires additional properties to be provided.
 * 
 * To determine the list of allowed categories for a specific integration, you can:
 * - Follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide and use the [Get create account model](https://docs.codat.io/sync-for-expenses-api#/operations/get-create-chartOfAccounts-model).
 * - Refer to the integration's own documentation.
 * 
 * &gt; **Accounts with no category**
 * &gt;
 * &gt; If an account is pulled from the chart of accounts and its nominal code does not lie within the category layout for the company's accounts, then the **type** is `Unknown`. The **fullyQualifiedCategory** and **fullyQualifiedName** fields return `null`.
 * &gt;
 * &gt; This approach gives a true representation of the company's accounts whilst preventing distorting financials such as a company's profit and loss and balance sheet reports.
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
@Deprecated
public class AccountingAccount {

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<? extends String> currency;

    /**
     * Current balance in the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currentBalance")
    private JsonNullable<? extends BigDecimal> currentBalance;

    /**
     * Description for the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<? extends String> description;

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullyQualifiedCategory")
    private JsonNullable<? extends String> fullyQualifiedCategory;

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullyQualifiedName")
    private JsonNullable<? extends String> fullyQualifiedName;

    /**
     * Identifier for the account, unique for the company.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<? extends String> id;

    /**
     * Confirms whether the account is a bank account or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isBankAccount")
    private Optional<? extends Boolean> isBankAccount;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends CreateAccountResponseMetadata> metadata;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<? extends String> modifiedDate;

    /**
     * Name of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private JsonNullable<? extends String> name;

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nominalCode")
    private JsonNullable<? extends String> nominalCode;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<? extends String> sourceModifiedDate;

    /**
     * Status of the account
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends AccountStatus> status;

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplementalData")
    private Optional<? extends SupplementalData> supplementalData;

    /**
     * Type of account
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends AccountType> type;

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("validDatatypeLinks")
    private JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks;

    public AccountingAccount(
            @JsonProperty("currency") Optional<? extends String> currency,
            @JsonProperty("currentBalance") JsonNullable<? extends BigDecimal> currentBalance,
            @JsonProperty("description") JsonNullable<? extends String> description,
            @JsonProperty("fullyQualifiedCategory") JsonNullable<? extends String> fullyQualifiedCategory,
            @JsonProperty("fullyQualifiedName") JsonNullable<? extends String> fullyQualifiedName,
            @JsonProperty("id") Optional<? extends String> id,
            @JsonProperty("isBankAccount") Optional<? extends Boolean> isBankAccount,
            @JsonProperty("metadata") Optional<? extends CreateAccountResponseMetadata> metadata,
            @JsonProperty("modifiedDate") Optional<? extends String> modifiedDate,
            @JsonProperty("name") JsonNullable<? extends String> name,
            @JsonProperty("nominalCode") JsonNullable<? extends String> nominalCode,
            @JsonProperty("sourceModifiedDate") Optional<? extends String> sourceModifiedDate,
            @JsonProperty("status") Optional<? extends AccountStatus> status,
            @JsonProperty("supplementalData") Optional<? extends SupplementalData> supplementalData,
            @JsonProperty("type") Optional<? extends AccountType> type,
            @JsonProperty("validDatatypeLinks") JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks) {
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currentBalance, "currentBalance");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(nominalCode, "nominalCode");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(supplementalData, "supplementalData");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.currency = currency;
        this.currentBalance = currentBalance;
        this.description = description;
        this.fullyQualifiedCategory = fullyQualifiedCategory;
        this.fullyQualifiedName = fullyQualifiedName;
        this.id = id;
        this.isBankAccount = isBankAccount;
        this.metadata = metadata;
        this.modifiedDate = modifiedDate;
        this.name = name;
        this.nominalCode = nominalCode;
        this.sourceModifiedDate = sourceModifiedDate;
        this.status = status;
        this.supplementalData = supplementalData;
        this.type = type;
        this.validDatatypeLinks = validDatatypeLinks;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public Optional<? extends String> currency() {
        return currency;
    }

    /**
     * Current balance in the account.
     */
    public JsonNullable<? extends BigDecimal> currentBalance() {
        return currentBalance;
    }

    /**
     * Description for the account.
     */
    public JsonNullable<? extends String> description() {
        return description;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    public JsonNullable<? extends String> fullyQualifiedCategory() {
        return fullyQualifiedCategory;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    public JsonNullable<? extends String> fullyQualifiedName() {
        return fullyQualifiedName;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    public Optional<? extends String> id() {
        return id;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    public Optional<? extends Boolean> isBankAccount() {
        return isBankAccount;
    }

    public Optional<? extends CreateAccountResponseMetadata> metadata() {
        return metadata;
    }

    public Optional<? extends String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Name of the account.
     */
    public JsonNullable<? extends String> name() {
        return name;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    public JsonNullable<? extends String> nominalCode() {
        return nominalCode;
    }

    public Optional<? extends String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * Status of the account
     */
    public Optional<? extends AccountStatus> status() {
        return status;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public Optional<? extends SupplementalData> supplementalData() {
        return supplementalData;
    }

    /**
     * Type of account
     */
    public Optional<? extends AccountType> type() {
        return type;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
     */
    public JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks() {
        return validDatatypeLinks;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public AccountingAccount withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public AccountingAccount withCurrency(Optional<? extends String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Current balance in the account.
     */
    public AccountingAccount withCurrentBalance(BigDecimal currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = JsonNullable.of(currentBalance);
        return this;
    }

        /**
         * Current balance in the account.
         */
    public AccountingAccount withCurrentBalance(double currentBalance) {
        this.currentBalance = JsonNullable.of(BigDecimal.valueOf(currentBalance));
        return this;
    }

    /**
     * Current balance in the account.
     */
    public AccountingAccount withCurrentBalance(JsonNullable<? extends BigDecimal> currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = currentBalance;
        return this;
    }

    /**
     * Description for the account.
     */
    public AccountingAccount withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = JsonNullable.of(description);
        return this;
    }

    /**
     * Description for the account.
     */
    public AccountingAccount withDescription(JsonNullable<? extends String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    public AccountingAccount withFullyQualifiedCategory(String fullyQualifiedCategory) {
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        this.fullyQualifiedCategory = JsonNullable.of(fullyQualifiedCategory);
        return this;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    public AccountingAccount withFullyQualifiedCategory(JsonNullable<? extends String> fullyQualifiedCategory) {
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        this.fullyQualifiedCategory = fullyQualifiedCategory;
        return this;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    public AccountingAccount withFullyQualifiedName(String fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
        return this;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    public AccountingAccount withFullyQualifiedName(JsonNullable<? extends String> fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = fullyQualifiedName;
        return this;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    public AccountingAccount withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    public AccountingAccount withId(Optional<? extends String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    public AccountingAccount withIsBankAccount(boolean isBankAccount) {
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        this.isBankAccount = Optional.ofNullable(isBankAccount);
        return this;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    public AccountingAccount withIsBankAccount(Optional<? extends Boolean> isBankAccount) {
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        this.isBankAccount = isBankAccount;
        return this;
    }

    public AccountingAccount withMetadata(CreateAccountResponseMetadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public AccountingAccount withMetadata(Optional<? extends CreateAccountResponseMetadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public AccountingAccount withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }

    public AccountingAccount withModifiedDate(Optional<? extends String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Name of the account.
     */
    public AccountingAccount withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = JsonNullable.of(name);
        return this;
    }

    /**
     * Name of the account.
     */
    public AccountingAccount withName(JsonNullable<? extends String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    public AccountingAccount withNominalCode(String nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = JsonNullable.of(nominalCode);
        return this;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    public AccountingAccount withNominalCode(JsonNullable<? extends String> nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = nominalCode;
        return this;
    }

    public AccountingAccount withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }

    public AccountingAccount withSourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * Status of the account
     */
    public AccountingAccount withStatus(AccountStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * Status of the account
     */
    public AccountingAccount withStatus(Optional<? extends AccountStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public AccountingAccount withSupplementalData(SupplementalData supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = Optional.ofNullable(supplementalData);
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public AccountingAccount withSupplementalData(Optional<? extends SupplementalData> supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = supplementalData;
        return this;
    }

    /**
     * Type of account
     */
    public AccountingAccount withType(AccountType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * Type of account
     */
    public AccountingAccount withType(Optional<? extends AccountType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
     */
    public AccountingAccount withValidDatatypeLinks(java.util.List<CreateAccountResponseValidDataTypeLinks> validDatatypeLinks) {
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.validDatatypeLinks = JsonNullable.of(validDatatypeLinks);
        return this;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
     */
    public AccountingAccount withValidDatatypeLinks(JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks) {
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.validDatatypeLinks = validDatatypeLinks;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AccountingAccount other = (AccountingAccount) o;
        return 
            java.util.Objects.deepEquals(this.currency, other.currency) &&
            java.util.Objects.deepEquals(this.currentBalance, other.currentBalance) &&
            java.util.Objects.deepEquals(this.description, other.description) &&
            java.util.Objects.deepEquals(this.fullyQualifiedCategory, other.fullyQualifiedCategory) &&
            java.util.Objects.deepEquals(this.fullyQualifiedName, other.fullyQualifiedName) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.isBankAccount, other.isBankAccount) &&
            java.util.Objects.deepEquals(this.metadata, other.metadata) &&
            java.util.Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.nominalCode, other.nominalCode) &&
            java.util.Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            java.util.Objects.deepEquals(this.status, other.status) &&
            java.util.Objects.deepEquals(this.supplementalData, other.supplementalData) &&
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.validDatatypeLinks, other.validDatatypeLinks);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            currency,
            currentBalance,
            description,
            fullyQualifiedCategory,
            fullyQualifiedName,
            id,
            isBankAccount,
            metadata,
            modifiedDate,
            name,
            nominalCode,
            sourceModifiedDate,
            status,
            supplementalData,
            type,
            validDatatypeLinks);
    }
    
    @Override
    public String toString() {
        return Utils.toString(AccountingAccount.class,
                "currency", currency,
                "currentBalance", currentBalance,
                "description", description,
                "fullyQualifiedCategory", fullyQualifiedCategory,
                "fullyQualifiedName", fullyQualifiedName,
                "id", id,
                "isBankAccount", isBankAccount,
                "metadata", metadata,
                "modifiedDate", modifiedDate,
                "name", name,
                "nominalCode", nominalCode,
                "sourceModifiedDate", sourceModifiedDate,
                "status", status,
                "supplementalData", supplementalData,
                "type", type,
                "validDatatypeLinks", validDatatypeLinks);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> currency = Optional.empty();
 
        private JsonNullable<? extends BigDecimal> currentBalance = JsonNullable.undefined();
 
        private JsonNullable<? extends String> description = JsonNullable.undefined();
 
        private JsonNullable<? extends String> fullyQualifiedCategory = JsonNullable.undefined();
 
        private JsonNullable<? extends String> fullyQualifiedName = JsonNullable.undefined();
 
        private Optional<? extends String> id = Optional.empty();
 
        private Optional<? extends Boolean> isBankAccount = Optional.empty();
 
        private Optional<? extends CreateAccountResponseMetadata> metadata = Optional.empty();
 
        private Optional<? extends String> modifiedDate = Optional.empty();
 
        private JsonNullable<? extends String> name = JsonNullable.undefined();
 
        private JsonNullable<? extends String> nominalCode = JsonNullable.undefined();
 
        private Optional<? extends String> sourceModifiedDate = Optional.empty();
 
        private Optional<? extends AccountStatus> status = Optional.empty();
 
        private Optional<? extends SupplementalData> supplementalData = Optional.empty();
 
        private Optional<? extends AccountType> type = Optional.empty();
 
        private JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(Optional<? extends String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(BigDecimal currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = JsonNullable.of(currentBalance);
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(double currentBalance) {
            this.currentBalance = JsonNullable.of(BigDecimal.valueOf(currentBalance));
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(JsonNullable<? extends BigDecimal> currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = currentBalance;
            return this;
        }

        /**
         * Description for the account.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * Description for the account.
         */
        public Builder description(JsonNullable<? extends String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * Full category of the account. 
         * 
         * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
         */
        public Builder fullyQualifiedCategory(String fullyQualifiedCategory) {
            Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
            this.fullyQualifiedCategory = JsonNullable.of(fullyQualifiedCategory);
            return this;
        }

        /**
         * Full category of the account. 
         * 
         * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
         */
        public Builder fullyQualifiedCategory(JsonNullable<? extends String> fullyQualifiedCategory) {
            Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
            this.fullyQualifiedCategory = fullyQualifiedCategory;
            return this;
        }

        /**
         * Full name of the account, for example:
         * - `Cash On Hand`
         * - `Rents Held In Trust`
         * - `Fixed Asset`
         */
        public Builder fullyQualifiedName(String fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
            return this;
        }

        /**
         * Full name of the account, for example:
         * - `Cash On Hand`
         * - `Rents Held In Trust`
         * - `Fixed Asset`
         */
        public Builder fullyQualifiedName(JsonNullable<? extends String> fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = fullyQualifiedName;
            return this;
        }

        /**
         * Identifier for the account, unique for the company.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * Identifier for the account, unique for the company.
         */
        public Builder id(Optional<? extends String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Confirms whether the account is a bank account or not.
         */
        public Builder isBankAccount(boolean isBankAccount) {
            Utils.checkNotNull(isBankAccount, "isBankAccount");
            this.isBankAccount = Optional.ofNullable(isBankAccount);
            return this;
        }

        /**
         * Confirms whether the account is a bank account or not.
         */
        public Builder isBankAccount(Optional<? extends Boolean> isBankAccount) {
            Utils.checkNotNull(isBankAccount, "isBankAccount");
            this.isBankAccount = isBankAccount;
            return this;
        }

        public Builder metadata(CreateAccountResponseMetadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends CreateAccountResponseMetadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }

        public Builder modifiedDate(Optional<? extends String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Name of the account.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = JsonNullable.of(name);
            return this;
        }

        /**
         * Name of the account.
         */
        public Builder name(JsonNullable<? extends String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
         */
        public Builder nominalCode(String nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = JsonNullable.of(nominalCode);
            return this;
        }

        /**
         * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
         */
        public Builder nominalCode(JsonNullable<? extends String> nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = nominalCode;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }

        public Builder sourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * Status of the account
         */
        public Builder status(AccountStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Status of the account
         */
        public Builder status(Optional<? extends AccountStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(SupplementalData supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = Optional.ofNullable(supplementalData);
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting platform. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(Optional<? extends SupplementalData> supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = supplementalData;
            return this;
        }

        /**
         * Type of account
         */
        public Builder type(AccountType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * Type of account
         */
        public Builder type(Optional<? extends AccountType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
         */
        public Builder validDatatypeLinks(java.util.List<CreateAccountResponseValidDataTypeLinks> validDatatypeLinks) {
            Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
            this.validDatatypeLinks = JsonNullable.of(validDatatypeLinks);
            return this;
        }

        /**
         * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/sync-for-expenses-api#/schemas/ValidDataTypeLinks).
         */
        public Builder validDatatypeLinks(JsonNullable<? extends java.util.List<CreateAccountResponseValidDataTypeLinks>> validDatatypeLinks) {
            Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
            this.validDatatypeLinks = validDatatypeLinks;
            return this;
        }
        
        public AccountingAccount build() {
            return new AccountingAccount(
                currency,
                currentBalance,
                description,
                fullyQualifiedCategory,
                fullyQualifiedName,
                id,
                isBankAccount,
                metadata,
                modifiedDate,
                name,
                nominalCode,
                sourceModifiedDate,
                status,
                supplementalData,
                type,
                validDatatypeLinks);
        }
    }
}

