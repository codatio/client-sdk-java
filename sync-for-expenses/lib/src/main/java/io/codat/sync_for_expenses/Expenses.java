/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.sync_for_expenses;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.codat.sync_for_expenses.models.errors.SDKError;
import io.codat.sync_for_expenses.models.operations.SDKMethodInterfaces.*;
import io.codat.sync_for_expenses.utils.HTTPClient;
import io.codat.sync_for_expenses.utils.HTTPRequest;
import io.codat.sync_for_expenses.utils.JSON;
import io.codat.sync_for_expenses.utils.SerializedBody;
import io.codat.sync_for_expenses.utils.Utils;
import java.io.InputStream;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * Create expense datasets and upload receipts.
 */
public class Expenses implements
            MethodCallCreateExpenseTransaction,
            MethodCallUpdateExpenseTransaction,
            MethodCallUploadExpenseAttachment {
    
    private final SDKConfiguration sdkConfiguration;

    Expenses(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }
    public io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionRequestBuilder createExpenseTransaction() {
        return new io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionRequestBuilder(this);
    }

    /**
     * Create expense transaction
     * The *Create expense* endpoint creates an [expense transaction](https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction) in the accounting platform for a given company's connection. 
     * 
     * [Expense transactions](https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction) represent transactions made with a company debit or credit card. 
     * 
     * 
     * **Integration-specific behaviour**
     * 
     * Some accounting platforms support the option of pushing transactions to a draft state. This can be done by setting the postAsDraft property on the transaction to true. For platforms without this feature, the postAsDraft property should be ignored or set to false.
     * 
     * | Integration | Draft State | Details                                                                                                      |  
     * |-------------|-------------|--------------------------------------------------------------------------------------------------------------|
     * | Dynamics 365 Business Central | Yes   | Setting postAsDraft to true will push the transactions to a drafted state rather than posting directly to the ledger. For transactions in a draft state, they can then be approved and posted within the accounting platform. |
     * | Quickbooks Online | No | -  |
     * | Xero | No | - |
     * | NetSuite | No | - |
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionResponse createExpenseTransaction(
            io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionRequest request) throws Exception {
        String baseUrl = this.sdkConfiguration.serverUrl;
        String url = io.codat.sync_for_expenses.utils.Utils.generateURL(
                io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionRequest.class, 
                baseUrl, 
                "/companies/{companyId}/sync/expenses/data/expense-transactions", 
                request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        SerializedBody serializedRequestBody = io.codat.sync_for_expenses.utils.Utils.serializeRequestBody(
                request, "createExpenseRequest", "json", false);
        req.setBody(serializedRequestBody);

        req.addHeader("Accept", "application/json");
        req.addHeader("user-agent", this.sdkConfiguration.userAgent);
        
        HTTPClient client = io.codat.sync_for_expenses.utils.Utils.configureSecurityClient(
                this.sdkConfiguration.defaultClient, this.sdkConfiguration.securitySource.getSecurity());
        
        HttpResponse<InputStream> httpRes = client.send(req);

        String contentType = httpRes
                .headers()
                .firstValue("Content-Type")
                .orElse("application/octet-stream");

        io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionResponse.Builder resBuilder = 
            io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionResponse
                .builder()
                .contentType(contentType)
                .statusCode(httpRes.statusCode())
                .rawResponse(httpRes);

        io.codat.sync_for_expenses.models.operations.CreateExpenseTransactionResponse res = resBuilder.build();

        res.withRawResponse(httpRes);
        
        if (httpRes.statusCode() == 200) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.CreateExpenseResponse out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.CreateExpenseResponse>() {});
                res.withCreateExpenseResponse(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        } else if (httpRes.statusCode() == 400 || httpRes.statusCode() == 401 || httpRes.statusCode() == 402 || httpRes.statusCode() == 403 || httpRes.statusCode() == 404 || httpRes.statusCode() == 429 || httpRes.statusCode() == 500 || httpRes.statusCode() == 503) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.ErrorMessage out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.ErrorMessage>() {});
                res.withErrorMessage(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        }

        return res;
    }

    public io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionRequestBuilder updateExpenseTransaction() {
        return new io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionRequestBuilder(this);
    }

    /**
     * Update expense-transactions
     * The *Update expense* endpoint updates an existing [expense transaction](https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction) in the accounting platform for a given company's connection. 
     * 
     * [Expense transactions](https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction) represent transactions made with a company debit or credit card. 
     * 
     * 
     * **Integration-specific behaviour**
     * 
     * At the moment you can update expenses only for Xero ([Payment](https://docs.codat.io/expenses/sync-process/expense-transactions#transaction-types) transaction type only).
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionResponse updateExpenseTransaction(
            io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionRequest request) throws Exception {
        String baseUrl = this.sdkConfiguration.serverUrl;
        String url = io.codat.sync_for_expenses.utils.Utils.generateURL(
                io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionRequest.class, 
                baseUrl, 
                "/companies/{companyId}/sync/expenses/expense-transactions/{transactionId}", 
                request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("PUT");
        req.setURL(url);
        SerializedBody serializedRequestBody = io.codat.sync_for_expenses.utils.Utils.serializeRequestBody(
                request, "updateExpenseRequest", "json", false);
        req.setBody(serializedRequestBody);

        req.addHeader("Accept", "application/json");
        req.addHeader("user-agent", this.sdkConfiguration.userAgent);
        
        HTTPClient client = io.codat.sync_for_expenses.utils.Utils.configureSecurityClient(
                this.sdkConfiguration.defaultClient, this.sdkConfiguration.securitySource.getSecurity());
        
        HttpResponse<InputStream> httpRes = client.send(req);

        String contentType = httpRes
                .headers()
                .firstValue("Content-Type")
                .orElse("application/octet-stream");

        io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionResponse.Builder resBuilder = 
            io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionResponse
                .builder()
                .contentType(contentType)
                .statusCode(httpRes.statusCode())
                .rawResponse(httpRes);

        io.codat.sync_for_expenses.models.operations.UpdateExpenseTransactionResponse res = resBuilder.build();

        res.withRawResponse(httpRes);
        
        if (httpRes.statusCode() == 202) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.UpdateExpenseResponse out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.UpdateExpenseResponse>() {});
                res.withUpdateExpenseResponse(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        } else if (httpRes.statusCode() == 400 || httpRes.statusCode() == 401 || httpRes.statusCode() == 402 || httpRes.statusCode() == 403 || httpRes.statusCode() == 404 || httpRes.statusCode() == 422 || httpRes.statusCode() == 429 || httpRes.statusCode() == 500 || httpRes.statusCode() == 503) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.ErrorMessage out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.ErrorMessage>() {});
                res.withErrorMessage(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        }

        return res;
    }

    public io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentRequestBuilder uploadExpenseAttachment() {
        return new io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentRequestBuilder(this);
    }

    /**
     * Upload attachment
     * The *Upload attachment* endpoint uploads an attachment in the accounting software against the given transactionId. 
     * 
     * [Expense transactions](https://docs.codat.io/sync-for-expenses-api#/schemas/ExpenseTransaction) represent transactions made with a company debit or credit card. 
     * 
     * **Integration-specific behaviour**
     * 
     * Each accounting software supports different file formats and sizes.
     * 
     * | Integration | File Size | File Extension                                                                                                      |  
     * |-------------|-------------|--------------------------------------------------------------------------------------------------------------|
     * | Xero | 4MB  | 7Z, BMP, CSV, DOC, DOCX, EML, GIF, JPEG, JPG, KEYNOTE, MSG, NUMBERS, ODF, ODS, ODT, PAGES, PDF, PNG, PPT, PPTX, RAR, RTF, TIF, TIFF, TXT, XLS, XLSX, ZIP |
     * | QuickBooks Online | 100MB | AI, CSV, DOC, DOCX, EPS, GIF, JPEG, JPG, ODS, PAGES, PDF, PNG, RTF, TIF, TXT, XLS, XLSX, XML  |
     * | NetSuite | 100MB | BMP, CSV, XLS, XLSX, JSON, PDF, PJPG, PJPEG, PNG, TXT, SVG, TIF, TIFF, DOC, DOCX, ZIP |
     * | Dynamics 365 Business Central | 350 MB | Dynamics do not explicitly outline which file types are supported but they do state &lt;a className="external" href="https://learn.microsoft.com/en-gb/dynamics365/business-central/ui-how-add-link-to-record#to-attach-a-file-to-a-purchase-invoice" target="_blank"&gt;here&lt;/a&gt; that "You can attach any type of file, such as text, image, or video files". |
     * @param request the request object containing all of the parameters for the API call
     * @return the response from the API call
     * @throws Exception if the API call fails
     */
    public io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentResponse uploadExpenseAttachment(
            io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentRequest request) throws Exception {
        String baseUrl = this.sdkConfiguration.serverUrl;
        String url = io.codat.sync_for_expenses.utils.Utils.generateURL(
                io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentRequest.class, 
                baseUrl, 
                "/companies/{companyId}/sync/expenses/syncs/{syncId}/transactions/{transactionId}/attachments", 
                request, null);
        
        HTTPRequest req = new HTTPRequest();
        req.setMethod("POST");
        req.setURL(url);
        SerializedBody serializedRequestBody = io.codat.sync_for_expenses.utils.Utils.serializeRequestBody(
                request, "attachmentUpload", "multipart", false);
        req.setBody(serializedRequestBody);

        req.addHeader("Accept", "application/json");
        req.addHeader("user-agent", this.sdkConfiguration.userAgent);
        
        HTTPClient client = io.codat.sync_for_expenses.utils.Utils.configureSecurityClient(
                this.sdkConfiguration.defaultClient, this.sdkConfiguration.securitySource.getSecurity());
        
        HttpResponse<InputStream> httpRes = client.send(req);

        String contentType = httpRes
                .headers()
                .firstValue("Content-Type")
                .orElse("application/octet-stream");

        io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentResponse.Builder resBuilder = 
            io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentResponse
                .builder()
                .contentType(contentType)
                .statusCode(httpRes.statusCode())
                .rawResponse(httpRes);

        io.codat.sync_for_expenses.models.operations.UploadExpenseAttachmentResponse res = resBuilder.build();

        res.withRawResponse(httpRes);
        
        if (httpRes.statusCode() == 200) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.Attachment out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.Attachment>() {});
                res.withAttachment(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        } else if (httpRes.statusCode() == 400 || httpRes.statusCode() == 401 || httpRes.statusCode() == 402 || httpRes.statusCode() == 403 || httpRes.statusCode() == 404 || httpRes.statusCode() == 429 || httpRes.statusCode() == 500 || httpRes.statusCode() == 503) {
            if (io.codat.sync_for_expenses.utils.Utils.matchContentType(contentType, "application/json")) {
                ObjectMapper mapper = JSON.getMapper();
                io.codat.sync_for_expenses.models.shared.ErrorMessage out = mapper.readValue(
                    Utils.toUtf8AndClose(httpRes.body()),
                    new TypeReference<io.codat.sync_for_expenses.models.shared.ErrorMessage>() {});
                res.withErrorMessage(java.util.Optional.ofNullable(out));
            } else {
                throw new SDKError(httpRes, httpRes.statusCode(), "Unknown content-type received: " + contentType, Utils.toByteArrayAndClose(httpRes.body()));
            }
        }

        return res;
    }

}
