/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.lending.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.io.InputStream;
import java.util.Optional;

/**
 * AccountsPayableTracking - Categories, and a project and customer, against which the item is tracked.
 */

public class AccountsPayableTracking {

    @JsonProperty("categoryRefs")
    private java.util.List<TrackingCategoryRef> categoryRefs;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerRef")
    private Optional<? extends AccountingCustomerRef> customerRef;

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    @JsonProperty("isBilledTo")
    private BilledToType isBilledTo;

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    @JsonProperty("isRebilledTo")
    private BilledToType isRebilledTo;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("projectRef")
    private Optional<? extends ProjectRef> projectRef;

    public AccountsPayableTracking(
            @JsonProperty("categoryRefs") java.util.List<TrackingCategoryRef> categoryRefs,
            @JsonProperty("customerRef") Optional<? extends AccountingCustomerRef> customerRef,
            @JsonProperty("isBilledTo") BilledToType isBilledTo,
            @JsonProperty("isRebilledTo") BilledToType isRebilledTo,
            @JsonProperty("projectRef") Optional<? extends ProjectRef> projectRef) {
        Utils.checkNotNull(categoryRefs, "categoryRefs");
        Utils.checkNotNull(customerRef, "customerRef");
        Utils.checkNotNull(isBilledTo, "isBilledTo");
        Utils.checkNotNull(isRebilledTo, "isRebilledTo");
        Utils.checkNotNull(projectRef, "projectRef");
        this.categoryRefs = categoryRefs;
        this.customerRef = customerRef;
        this.isBilledTo = isBilledTo;
        this.isRebilledTo = isRebilledTo;
        this.projectRef = projectRef;
    }

    public java.util.List<TrackingCategoryRef> categoryRefs() {
        return categoryRefs;
    }

    public Optional<? extends AccountingCustomerRef> customerRef() {
        return customerRef;
    }

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    public BilledToType isBilledTo() {
        return isBilledTo;
    }

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    public BilledToType isRebilledTo() {
        return isRebilledTo;
    }

    public Optional<? extends ProjectRef> projectRef() {
        return projectRef;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    public AccountsPayableTracking withCategoryRefs(java.util.List<TrackingCategoryRef> categoryRefs) {
        Utils.checkNotNull(categoryRefs, "categoryRefs");
        this.categoryRefs = categoryRefs;
        return this;
    }

    public AccountsPayableTracking withCustomerRef(AccountingCustomerRef customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = Optional.ofNullable(customerRef);
        return this;
    }
    
    public AccountsPayableTracking withCustomerRef(Optional<? extends AccountingCustomerRef> customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = customerRef;
        return this;
    }

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    public AccountsPayableTracking withIsBilledTo(BilledToType isBilledTo) {
        Utils.checkNotNull(isBilledTo, "isBilledTo");
        this.isBilledTo = isBilledTo;
        return this;
    }

    /**
     * Defines if the invoice or credit note is billed/rebilled to a project or customer.
     */
    public AccountsPayableTracking withIsRebilledTo(BilledToType isRebilledTo) {
        Utils.checkNotNull(isRebilledTo, "isRebilledTo");
        this.isRebilledTo = isRebilledTo;
        return this;
    }

    public AccountsPayableTracking withProjectRef(ProjectRef projectRef) {
        Utils.checkNotNull(projectRef, "projectRef");
        this.projectRef = Optional.ofNullable(projectRef);
        return this;
    }
    
    public AccountsPayableTracking withProjectRef(Optional<? extends ProjectRef> projectRef) {
        Utils.checkNotNull(projectRef, "projectRef");
        this.projectRef = projectRef;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AccountsPayableTracking other = (AccountsPayableTracking) o;
        return 
            java.util.Objects.deepEquals(this.categoryRefs, other.categoryRefs) &&
            java.util.Objects.deepEquals(this.customerRef, other.customerRef) &&
            java.util.Objects.deepEquals(this.isBilledTo, other.isBilledTo) &&
            java.util.Objects.deepEquals(this.isRebilledTo, other.isRebilledTo) &&
            java.util.Objects.deepEquals(this.projectRef, other.projectRef);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            categoryRefs,
            customerRef,
            isBilledTo,
            isRebilledTo,
            projectRef);
    }
    
    @Override
    public String toString() {
        return Utils.toString(AccountsPayableTracking.class,
                "categoryRefs", categoryRefs,
                "customerRef", customerRef,
                "isBilledTo", isBilledTo,
                "isRebilledTo", isRebilledTo,
                "projectRef", projectRef);
    }
    
    public final static class Builder {
 
        private java.util.List<TrackingCategoryRef> categoryRefs;
 
        private Optional<? extends AccountingCustomerRef> customerRef = Optional.empty();
 
        private BilledToType isBilledTo;
 
        private BilledToType isRebilledTo;
 
        private Optional<? extends ProjectRef> projectRef = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder categoryRefs(java.util.List<TrackingCategoryRef> categoryRefs) {
            Utils.checkNotNull(categoryRefs, "categoryRefs");
            this.categoryRefs = categoryRefs;
            return this;
        }

        public Builder customerRef(AccountingCustomerRef customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = Optional.ofNullable(customerRef);
            return this;
        }
        
        public Builder customerRef(Optional<? extends AccountingCustomerRef> customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = customerRef;
            return this;
        }

        /**
         * Defines if the invoice or credit note is billed/rebilled to a project or customer.
         */
        public Builder isBilledTo(BilledToType isBilledTo) {
            Utils.checkNotNull(isBilledTo, "isBilledTo");
            this.isBilledTo = isBilledTo;
            return this;
        }

        /**
         * Defines if the invoice or credit note is billed/rebilled to a project or customer.
         */
        public Builder isRebilledTo(BilledToType isRebilledTo) {
            Utils.checkNotNull(isRebilledTo, "isRebilledTo");
            this.isRebilledTo = isRebilledTo;
            return this;
        }

        public Builder projectRef(ProjectRef projectRef) {
            Utils.checkNotNull(projectRef, "projectRef");
            this.projectRef = Optional.ofNullable(projectRef);
            return this;
        }
        
        public Builder projectRef(Optional<? extends ProjectRef> projectRef) {
            Utils.checkNotNull(projectRef, "projectRef");
            this.projectRef = projectRef;
            return this;
        }        
        
        public AccountsPayableTracking build() {
            return new AccountsPayableTracking(
                categoryRefs,
                customerRef,
                isBilledTo,
                isRebilledTo,
                projectRef);
        }
    }
}

