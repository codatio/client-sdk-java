/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.lending.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.io.InputStream;
import java.util.Optional;

/**
 * ProductVariant - Represents a variation of a product available for sale, for example an item of clothing that may be available for sale in multiple sizes and colors.
 * 
 */

public class ProductVariant {

    /**
     * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("barcode")
    private Optional<? extends String> barcode;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdDate")
    private Optional<? extends String> createdDate;

    /**
     * A unique, persistent identifier for this record
     */
    @JsonProperty("id")
    private String id;

    /**
     * Information about the total inventory as well as the locations inventory is in.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("inventory")
    private Optional<? extends ProductInventory> inventory;

    /**
     * Whether sales taxes are enabled for this product variant.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isTaxEnabled")
    private Optional<? extends Boolean> isTaxEnabled;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<? extends String> modifiedDate;

    /**
     * Name of the product recorded in the commerce or point of sale platform.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private Optional<? extends String> name;

    /**
     * Prices for the product variants in different currencies.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("prices")
    private Optional<? extends java.util.List<ProductPrice>> prices;

    /**
     * Indicates whether or not the product requires physical delivery.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shippingRequired")
    private Optional<? extends Boolean> shippingRequired;

    /**
     * SKU (stock keeping unit) of the variant, as defined by the merchant.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sku")
    private Optional<? extends String> sku;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<? extends String> sourceModifiedDate;

    /**
     * The status of the product variant.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends ProductVariantStatus> status;

    /**
     * Unit of measure for the variant, such as `kg` or `meters`.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unitOfMeasure")
    private Optional<? extends String> unitOfMeasure;

    /**
     * VAT rate for the product variant if sales taxes are enabled.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("vatPercentage")
    private Optional<? extends Double> vatPercentage;

    public ProductVariant(
            @JsonProperty("barcode") Optional<? extends String> barcode,
            @JsonProperty("createdDate") Optional<? extends String> createdDate,
            @JsonProperty("id") String id,
            @JsonProperty("inventory") Optional<? extends ProductInventory> inventory,
            @JsonProperty("isTaxEnabled") Optional<? extends Boolean> isTaxEnabled,
            @JsonProperty("modifiedDate") Optional<? extends String> modifiedDate,
            @JsonProperty("name") Optional<? extends String> name,
            @JsonProperty("prices") Optional<? extends java.util.List<ProductPrice>> prices,
            @JsonProperty("shippingRequired") Optional<? extends Boolean> shippingRequired,
            @JsonProperty("sku") Optional<? extends String> sku,
            @JsonProperty("sourceModifiedDate") Optional<? extends String> sourceModifiedDate,
            @JsonProperty("status") Optional<? extends ProductVariantStatus> status,
            @JsonProperty("unitOfMeasure") Optional<? extends String> unitOfMeasure,
            @JsonProperty("vatPercentage") Optional<? extends Double> vatPercentage) {
        Utils.checkNotNull(barcode, "barcode");
        Utils.checkNotNull(createdDate, "createdDate");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(inventory, "inventory");
        Utils.checkNotNull(isTaxEnabled, "isTaxEnabled");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(prices, "prices");
        Utils.checkNotNull(shippingRequired, "shippingRequired");
        Utils.checkNotNull(sku, "sku");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(unitOfMeasure, "unitOfMeasure");
        Utils.checkNotNull(vatPercentage, "vatPercentage");
        this.barcode = barcode;
        this.createdDate = createdDate;
        this.id = id;
        this.inventory = inventory;
        this.isTaxEnabled = isTaxEnabled;
        this.modifiedDate = modifiedDate;
        this.name = name;
        this.prices = prices;
        this.shippingRequired = shippingRequired;
        this.sku = sku;
        this.sourceModifiedDate = sourceModifiedDate;
        this.status = status;
        this.unitOfMeasure = unitOfMeasure;
        this.vatPercentage = vatPercentage;
    }

    /**
     * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
     */
    public Optional<? extends String> barcode() {
        return barcode;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> createdDate() {
        return createdDate;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public String id() {
        return id;
    }

    /**
     * Information about the total inventory as well as the locations inventory is in.
     */
    public Optional<? extends ProductInventory> inventory() {
        return inventory;
    }

    /**
     * Whether sales taxes are enabled for this product variant.
     */
    public Optional<? extends Boolean> isTaxEnabled() {
        return isTaxEnabled;
    }

    public Optional<? extends String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Name of the product recorded in the commerce or point of sale platform.
     */
    public Optional<? extends String> name() {
        return name;
    }

    /**
     * Prices for the product variants in different currencies.
     */
    public Optional<? extends java.util.List<ProductPrice>> prices() {
        return prices;
    }

    /**
     * Indicates whether or not the product requires physical delivery.
     */
    public Optional<? extends Boolean> shippingRequired() {
        return shippingRequired;
    }

    /**
     * SKU (stock keeping unit) of the variant, as defined by the merchant.
     */
    public Optional<? extends String> sku() {
        return sku;
    }

    public Optional<? extends String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * The status of the product variant.
     */
    public Optional<? extends ProductVariantStatus> status() {
        return status;
    }

    /**
     * Unit of measure for the variant, such as `kg` or `meters`.
     */
    public Optional<? extends String> unitOfMeasure() {
        return unitOfMeasure;
    }

    /**
     * VAT rate for the product variant if sales taxes are enabled.
     */
    public Optional<? extends Double> vatPercentage() {
        return vatPercentage;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
     */
    public ProductVariant withBarcode(String barcode) {
        Utils.checkNotNull(barcode, "barcode");
        this.barcode = Optional.ofNullable(barcode);
        return this;
    }
    
    /**
     * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
     */
    public ProductVariant withBarcode(Optional<? extends String> barcode) {
        Utils.checkNotNull(barcode, "barcode");
        this.barcode = barcode;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProductVariant withCreatedDate(String createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = Optional.ofNullable(createdDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProductVariant withCreatedDate(Optional<? extends String> createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = createdDate;
        return this;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public ProductVariant withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Information about the total inventory as well as the locations inventory is in.
     */
    public ProductVariant withInventory(ProductInventory inventory) {
        Utils.checkNotNull(inventory, "inventory");
        this.inventory = Optional.ofNullable(inventory);
        return this;
    }
    
    /**
     * Information about the total inventory as well as the locations inventory is in.
     */
    public ProductVariant withInventory(Optional<? extends ProductInventory> inventory) {
        Utils.checkNotNull(inventory, "inventory");
        this.inventory = inventory;
        return this;
    }

    /**
     * Whether sales taxes are enabled for this product variant.
     */
    public ProductVariant withIsTaxEnabled(boolean isTaxEnabled) {
        Utils.checkNotNull(isTaxEnabled, "isTaxEnabled");
        this.isTaxEnabled = Optional.ofNullable(isTaxEnabled);
        return this;
    }
    
    /**
     * Whether sales taxes are enabled for this product variant.
     */
    public ProductVariant withIsTaxEnabled(Optional<? extends Boolean> isTaxEnabled) {
        Utils.checkNotNull(isTaxEnabled, "isTaxEnabled");
        this.isTaxEnabled = isTaxEnabled;
        return this;
    }

    public ProductVariant withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }
    
    public ProductVariant withModifiedDate(Optional<? extends String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Name of the product recorded in the commerce or point of sale platform.
     */
    public ProductVariant withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = Optional.ofNullable(name);
        return this;
    }
    
    /**
     * Name of the product recorded in the commerce or point of sale platform.
     */
    public ProductVariant withName(Optional<? extends String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Prices for the product variants in different currencies.
     */
    public ProductVariant withPrices(java.util.List<ProductPrice> prices) {
        Utils.checkNotNull(prices, "prices");
        this.prices = Optional.ofNullable(prices);
        return this;
    }
    
    /**
     * Prices for the product variants in different currencies.
     */
    public ProductVariant withPrices(Optional<? extends java.util.List<ProductPrice>> prices) {
        Utils.checkNotNull(prices, "prices");
        this.prices = prices;
        return this;
    }

    /**
     * Indicates whether or not the product requires physical delivery.
     */
    public ProductVariant withShippingRequired(boolean shippingRequired) {
        Utils.checkNotNull(shippingRequired, "shippingRequired");
        this.shippingRequired = Optional.ofNullable(shippingRequired);
        return this;
    }
    
    /**
     * Indicates whether or not the product requires physical delivery.
     */
    public ProductVariant withShippingRequired(Optional<? extends Boolean> shippingRequired) {
        Utils.checkNotNull(shippingRequired, "shippingRequired");
        this.shippingRequired = shippingRequired;
        return this;
    }

    /**
     * SKU (stock keeping unit) of the variant, as defined by the merchant.
     */
    public ProductVariant withSku(String sku) {
        Utils.checkNotNull(sku, "sku");
        this.sku = Optional.ofNullable(sku);
        return this;
    }
    
    /**
     * SKU (stock keeping unit) of the variant, as defined by the merchant.
     */
    public ProductVariant withSku(Optional<? extends String> sku) {
        Utils.checkNotNull(sku, "sku");
        this.sku = sku;
        return this;
    }

    public ProductVariant withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }
    
    public ProductVariant withSourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * The status of the product variant.
     */
    public ProductVariant withStatus(ProductVariantStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }
    
    /**
     * The status of the product variant.
     */
    public ProductVariant withStatus(Optional<? extends ProductVariantStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Unit of measure for the variant, such as `kg` or `meters`.
     */
    public ProductVariant withUnitOfMeasure(String unitOfMeasure) {
        Utils.checkNotNull(unitOfMeasure, "unitOfMeasure");
        this.unitOfMeasure = Optional.ofNullable(unitOfMeasure);
        return this;
    }
    
    /**
     * Unit of measure for the variant, such as `kg` or `meters`.
     */
    public ProductVariant withUnitOfMeasure(Optional<? extends String> unitOfMeasure) {
        Utils.checkNotNull(unitOfMeasure, "unitOfMeasure");
        this.unitOfMeasure = unitOfMeasure;
        return this;
    }

    /**
     * VAT rate for the product variant if sales taxes are enabled.
     */
    public ProductVariant withVatPercentage(double vatPercentage) {
        Utils.checkNotNull(vatPercentage, "vatPercentage");
        this.vatPercentage = Optional.ofNullable(vatPercentage);
        return this;
    }
    
    /**
     * VAT rate for the product variant if sales taxes are enabled.
     */
    public ProductVariant withVatPercentage(Optional<? extends Double> vatPercentage) {
        Utils.checkNotNull(vatPercentage, "vatPercentage");
        this.vatPercentage = vatPercentage;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ProductVariant other = (ProductVariant) o;
        return 
            java.util.Objects.deepEquals(this.barcode, other.barcode) &&
            java.util.Objects.deepEquals(this.createdDate, other.createdDate) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.inventory, other.inventory) &&
            java.util.Objects.deepEquals(this.isTaxEnabled, other.isTaxEnabled) &&
            java.util.Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            java.util.Objects.deepEquals(this.name, other.name) &&
            java.util.Objects.deepEquals(this.prices, other.prices) &&
            java.util.Objects.deepEquals(this.shippingRequired, other.shippingRequired) &&
            java.util.Objects.deepEquals(this.sku, other.sku) &&
            java.util.Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            java.util.Objects.deepEquals(this.status, other.status) &&
            java.util.Objects.deepEquals(this.unitOfMeasure, other.unitOfMeasure) &&
            java.util.Objects.deepEquals(this.vatPercentage, other.vatPercentage);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            barcode,
            createdDate,
            id,
            inventory,
            isTaxEnabled,
            modifiedDate,
            name,
            prices,
            shippingRequired,
            sku,
            sourceModifiedDate,
            status,
            unitOfMeasure,
            vatPercentage);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ProductVariant.class,
                "barcode", barcode,
                "createdDate", createdDate,
                "id", id,
                "inventory", inventory,
                "isTaxEnabled", isTaxEnabled,
                "modifiedDate", modifiedDate,
                "name", name,
                "prices", prices,
                "shippingRequired", shippingRequired,
                "sku", sku,
                "sourceModifiedDate", sourceModifiedDate,
                "status", status,
                "unitOfMeasure", unitOfMeasure,
                "vatPercentage", vatPercentage);
    }
    
    public final static class Builder {
 
        private Optional<? extends String> barcode = Optional.empty();
 
        private Optional<? extends String> createdDate = Optional.empty();
 
        private String id;
 
        private Optional<? extends ProductInventory> inventory = Optional.empty();
 
        private Optional<? extends Boolean> isTaxEnabled = Optional.empty();
 
        private Optional<? extends String> modifiedDate = Optional.empty();
 
        private Optional<? extends String> name = Optional.empty();
 
        private Optional<? extends java.util.List<ProductPrice>> prices = Optional.empty();
 
        private Optional<? extends Boolean> shippingRequired = Optional.empty();
 
        private Optional<? extends String> sku = Optional.empty();
 
        private Optional<? extends String> sourceModifiedDate = Optional.empty();
 
        private Optional<? extends ProductVariantStatus> status = Optional.empty();
 
        private Optional<? extends String> unitOfMeasure = Optional.empty();
 
        private Optional<? extends Double> vatPercentage = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
         */
        public Builder barcode(String barcode) {
            Utils.checkNotNull(barcode, "barcode");
            this.barcode = Optional.ofNullable(barcode);
            return this;
        }
        
        /**
         * Unique product number of the variant. This might be a barcode, UPC, ISBN, etc.
         */
        public Builder barcode(Optional<? extends String> barcode) {
            Utils.checkNotNull(barcode, "barcode");
            this.barcode = barcode;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(String createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = Optional.ofNullable(createdDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(Optional<? extends String> createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = createdDate;
            return this;
        }

        /**
         * A unique, persistent identifier for this record
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Information about the total inventory as well as the locations inventory is in.
         */
        public Builder inventory(ProductInventory inventory) {
            Utils.checkNotNull(inventory, "inventory");
            this.inventory = Optional.ofNullable(inventory);
            return this;
        }
        
        /**
         * Information about the total inventory as well as the locations inventory is in.
         */
        public Builder inventory(Optional<? extends ProductInventory> inventory) {
            Utils.checkNotNull(inventory, "inventory");
            this.inventory = inventory;
            return this;
        }

        /**
         * Whether sales taxes are enabled for this product variant.
         */
        public Builder isTaxEnabled(boolean isTaxEnabled) {
            Utils.checkNotNull(isTaxEnabled, "isTaxEnabled");
            this.isTaxEnabled = Optional.ofNullable(isTaxEnabled);
            return this;
        }
        
        /**
         * Whether sales taxes are enabled for this product variant.
         */
        public Builder isTaxEnabled(Optional<? extends Boolean> isTaxEnabled) {
            Utils.checkNotNull(isTaxEnabled, "isTaxEnabled");
            this.isTaxEnabled = isTaxEnabled;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }
        
        public Builder modifiedDate(Optional<? extends String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Name of the product recorded in the commerce or point of sale platform.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = Optional.ofNullable(name);
            return this;
        }
        
        /**
         * Name of the product recorded in the commerce or point of sale platform.
         */
        public Builder name(Optional<? extends String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Prices for the product variants in different currencies.
         */
        public Builder prices(java.util.List<ProductPrice> prices) {
            Utils.checkNotNull(prices, "prices");
            this.prices = Optional.ofNullable(prices);
            return this;
        }
        
        /**
         * Prices for the product variants in different currencies.
         */
        public Builder prices(Optional<? extends java.util.List<ProductPrice>> prices) {
            Utils.checkNotNull(prices, "prices");
            this.prices = prices;
            return this;
        }

        /**
         * Indicates whether or not the product requires physical delivery.
         */
        public Builder shippingRequired(boolean shippingRequired) {
            Utils.checkNotNull(shippingRequired, "shippingRequired");
            this.shippingRequired = Optional.ofNullable(shippingRequired);
            return this;
        }
        
        /**
         * Indicates whether or not the product requires physical delivery.
         */
        public Builder shippingRequired(Optional<? extends Boolean> shippingRequired) {
            Utils.checkNotNull(shippingRequired, "shippingRequired");
            this.shippingRequired = shippingRequired;
            return this;
        }

        /**
         * SKU (stock keeping unit) of the variant, as defined by the merchant.
         */
        public Builder sku(String sku) {
            Utils.checkNotNull(sku, "sku");
            this.sku = Optional.ofNullable(sku);
            return this;
        }
        
        /**
         * SKU (stock keeping unit) of the variant, as defined by the merchant.
         */
        public Builder sku(Optional<? extends String> sku) {
            Utils.checkNotNull(sku, "sku");
            this.sku = sku;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }
        
        public Builder sourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * The status of the product variant.
         */
        public Builder status(ProductVariantStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }
        
        /**
         * The status of the product variant.
         */
        public Builder status(Optional<? extends ProductVariantStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Unit of measure for the variant, such as `kg` or `meters`.
         */
        public Builder unitOfMeasure(String unitOfMeasure) {
            Utils.checkNotNull(unitOfMeasure, "unitOfMeasure");
            this.unitOfMeasure = Optional.ofNullable(unitOfMeasure);
            return this;
        }
        
        /**
         * Unit of measure for the variant, such as `kg` or `meters`.
         */
        public Builder unitOfMeasure(Optional<? extends String> unitOfMeasure) {
            Utils.checkNotNull(unitOfMeasure, "unitOfMeasure");
            this.unitOfMeasure = unitOfMeasure;
            return this;
        }

        /**
         * VAT rate for the product variant if sales taxes are enabled.
         */
        public Builder vatPercentage(double vatPercentage) {
            Utils.checkNotNull(vatPercentage, "vatPercentage");
            this.vatPercentage = Optional.ofNullable(vatPercentage);
            return this;
        }
        
        /**
         * VAT rate for the product variant if sales taxes are enabled.
         */
        public Builder vatPercentage(Optional<? extends Double> vatPercentage) {
            Utils.checkNotNull(vatPercentage, "vatPercentage");
            this.vatPercentage = vatPercentage;
            return this;
        }        
        
        public ProductVariant build() {
            return new ProductVariant(
                barcode,
                createdDate,
                id,
                inventory,
                isTaxEnabled,
                modifiedDate,
                name,
                prices,
                shippingRequired,
                sku,
                sourceModifiedDate,
                status,
                unitOfMeasure,
                vatPercentage);
        }
    }
}

