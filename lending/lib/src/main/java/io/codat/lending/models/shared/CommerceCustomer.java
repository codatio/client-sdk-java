/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package io.codat.lending.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.io.InputStream;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * CommerceCustomer - When a customer places an order with the connected commerce store their details are added to the Customers dataset. You can use the data from the Customers endpoints to calculate key metrics, such as customer churn.
 * 
 * Explore our [data coverage](https://knowledge.codat.io/supported-features/commerce?view=tab-by-data-type&amp;dataType=commerce-customers) for this data type.
 */

public class CommerceCustomer {

    /**
     * Addresses of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("addresses")
    private Optional<? extends java.util.List<CommerceAddress>> addresses;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdDate")
    private Optional<? extends String> createdDate;

    /**
     * Name of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerName")
    private Optional<? extends String> customerName;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("defaultCurrency")
    private Optional<? extends String> defaultCurrency;

    /**
     * Email address of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("emailAddress")
    private Optional<? extends String> emailAddress;

    /**
     * A unique, persistent identifier for this record
     */
    @JsonProperty("id")
    private String id;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<? extends String> modifiedDate;

    /**
     * Any additional information about the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private Optional<? extends String> note;

    /**
     * A phone number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("phone")
    private JsonNullable<? extends String> phone;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<? extends String> sourceModifiedDate;

    public CommerceCustomer(
            @JsonProperty("addresses") Optional<? extends java.util.List<CommerceAddress>> addresses,
            @JsonProperty("createdDate") Optional<? extends String> createdDate,
            @JsonProperty("customerName") Optional<? extends String> customerName,
            @JsonProperty("defaultCurrency") Optional<? extends String> defaultCurrency,
            @JsonProperty("emailAddress") Optional<? extends String> emailAddress,
            @JsonProperty("id") String id,
            @JsonProperty("modifiedDate") Optional<? extends String> modifiedDate,
            @JsonProperty("note") Optional<? extends String> note,
            @JsonProperty("phone") JsonNullable<? extends String> phone,
            @JsonProperty("sourceModifiedDate") Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(addresses, "addresses");
        Utils.checkNotNull(createdDate, "createdDate");
        Utils.checkNotNull(customerName, "customerName");
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        Utils.checkNotNull(emailAddress, "emailAddress");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(note, "note");
        Utils.checkNotNull(phone, "phone");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.addresses = addresses;
        this.createdDate = createdDate;
        this.customerName = customerName;
        this.defaultCurrency = defaultCurrency;
        this.emailAddress = emailAddress;
        this.id = id;
        this.modifiedDate = modifiedDate;
        this.note = note;
        this.phone = phone;
        this.sourceModifiedDate = sourceModifiedDate;
    }

    /**
     * Addresses of the customer
     */
    public Optional<? extends java.util.List<CommerceAddress>> addresses() {
        return addresses;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public Optional<? extends String> createdDate() {
        return createdDate;
    }

    /**
     * Name of the customer
     */
    public Optional<? extends String> customerName() {
        return customerName;
    }

    public Optional<? extends String> defaultCurrency() {
        return defaultCurrency;
    }

    /**
     * Email address of the customer
     */
    public Optional<? extends String> emailAddress() {
        return emailAddress;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public String id() {
        return id;
    }

    public Optional<? extends String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Any additional information about the customer
     */
    public Optional<? extends String> note() {
        return note;
    }

    /**
     * A phone number.
     */
    public JsonNullable<? extends String> phone() {
        return phone;
    }

    public Optional<? extends String> sourceModifiedDate() {
        return sourceModifiedDate;
    }
    
    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Addresses of the customer
     */
    public CommerceCustomer withAddresses(java.util.List<CommerceAddress> addresses) {
        Utils.checkNotNull(addresses, "addresses");
        this.addresses = Optional.ofNullable(addresses);
        return this;
    }
    
    /**
     * Addresses of the customer
     */
    public CommerceCustomer withAddresses(Optional<? extends java.util.List<CommerceAddress>> addresses) {
        Utils.checkNotNull(addresses, "addresses");
        this.addresses = addresses;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceCustomer withCreatedDate(String createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = Optional.ofNullable(createdDate);
        return this;
    }
    
    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceCustomer withCreatedDate(Optional<? extends String> createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = createdDate;
        return this;
    }

    /**
     * Name of the customer
     */
    public CommerceCustomer withCustomerName(String customerName) {
        Utils.checkNotNull(customerName, "customerName");
        this.customerName = Optional.ofNullable(customerName);
        return this;
    }
    
    /**
     * Name of the customer
     */
    public CommerceCustomer withCustomerName(Optional<? extends String> customerName) {
        Utils.checkNotNull(customerName, "customerName");
        this.customerName = customerName;
        return this;
    }

    public CommerceCustomer withDefaultCurrency(String defaultCurrency) {
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        this.defaultCurrency = Optional.ofNullable(defaultCurrency);
        return this;
    }
    
    public CommerceCustomer withDefaultCurrency(Optional<? extends String> defaultCurrency) {
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        this.defaultCurrency = defaultCurrency;
        return this;
    }

    /**
     * Email address of the customer
     */
    public CommerceCustomer withEmailAddress(String emailAddress) {
        Utils.checkNotNull(emailAddress, "emailAddress");
        this.emailAddress = Optional.ofNullable(emailAddress);
        return this;
    }
    
    /**
     * Email address of the customer
     */
    public CommerceCustomer withEmailAddress(Optional<? extends String> emailAddress) {
        Utils.checkNotNull(emailAddress, "emailAddress");
        this.emailAddress = emailAddress;
        return this;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public CommerceCustomer withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public CommerceCustomer withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }
    
    public CommerceCustomer withModifiedDate(Optional<? extends String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Any additional information about the customer
     */
    public CommerceCustomer withNote(String note) {
        Utils.checkNotNull(note, "note");
        this.note = Optional.ofNullable(note);
        return this;
    }
    
    /**
     * Any additional information about the customer
     */
    public CommerceCustomer withNote(Optional<? extends String> note) {
        Utils.checkNotNull(note, "note");
        this.note = note;
        return this;
    }

    /**
     * A phone number.
     */
    public CommerceCustomer withPhone(String phone) {
        Utils.checkNotNull(phone, "phone");
        this.phone = JsonNullable.of(phone);
        return this;
    }

    /**
     * A phone number.
     */
    public CommerceCustomer withPhone(JsonNullable<? extends String> phone) {
        Utils.checkNotNull(phone, "phone");
        this.phone = phone;
        return this;
    }

    public CommerceCustomer withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }
    
    public CommerceCustomer withSourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CommerceCustomer other = (CommerceCustomer) o;
        return 
            java.util.Objects.deepEquals(this.addresses, other.addresses) &&
            java.util.Objects.deepEquals(this.createdDate, other.createdDate) &&
            java.util.Objects.deepEquals(this.customerName, other.customerName) &&
            java.util.Objects.deepEquals(this.defaultCurrency, other.defaultCurrency) &&
            java.util.Objects.deepEquals(this.emailAddress, other.emailAddress) &&
            java.util.Objects.deepEquals(this.id, other.id) &&
            java.util.Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            java.util.Objects.deepEquals(this.note, other.note) &&
            java.util.Objects.deepEquals(this.phone, other.phone) &&
            java.util.Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            addresses,
            createdDate,
            customerName,
            defaultCurrency,
            emailAddress,
            id,
            modifiedDate,
            note,
            phone,
            sourceModifiedDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CommerceCustomer.class,
                "addresses", addresses,
                "createdDate", createdDate,
                "customerName", customerName,
                "defaultCurrency", defaultCurrency,
                "emailAddress", emailAddress,
                "id", id,
                "modifiedDate", modifiedDate,
                "note", note,
                "phone", phone,
                "sourceModifiedDate", sourceModifiedDate);
    }
    
    public final static class Builder {
 
        private Optional<? extends java.util.List<CommerceAddress>> addresses = Optional.empty();
 
        private Optional<? extends String> createdDate = Optional.empty();
 
        private Optional<? extends String> customerName = Optional.empty();
 
        private Optional<? extends String> defaultCurrency = Optional.empty();
 
        private Optional<? extends String> emailAddress = Optional.empty();
 
        private String id;
 
        private Optional<? extends String> modifiedDate = Optional.empty();
 
        private Optional<? extends String> note = Optional.empty();
 
        private JsonNullable<? extends String> phone = JsonNullable.undefined();
 
        private Optional<? extends String> sourceModifiedDate = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Addresses of the customer
         */
        public Builder addresses(java.util.List<CommerceAddress> addresses) {
            Utils.checkNotNull(addresses, "addresses");
            this.addresses = Optional.ofNullable(addresses);
            return this;
        }
        
        /**
         * Addresses of the customer
         */
        public Builder addresses(Optional<? extends java.util.List<CommerceAddress>> addresses) {
            Utils.checkNotNull(addresses, "addresses");
            this.addresses = addresses;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(String createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = Optional.ofNullable(createdDate);
            return this;
        }
        
        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(Optional<? extends String> createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = createdDate;
            return this;
        }

        /**
         * Name of the customer
         */
        public Builder customerName(String customerName) {
            Utils.checkNotNull(customerName, "customerName");
            this.customerName = Optional.ofNullable(customerName);
            return this;
        }
        
        /**
         * Name of the customer
         */
        public Builder customerName(Optional<? extends String> customerName) {
            Utils.checkNotNull(customerName, "customerName");
            this.customerName = customerName;
            return this;
        }

        public Builder defaultCurrency(String defaultCurrency) {
            Utils.checkNotNull(defaultCurrency, "defaultCurrency");
            this.defaultCurrency = Optional.ofNullable(defaultCurrency);
            return this;
        }
        
        public Builder defaultCurrency(Optional<? extends String> defaultCurrency) {
            Utils.checkNotNull(defaultCurrency, "defaultCurrency");
            this.defaultCurrency = defaultCurrency;
            return this;
        }

        /**
         * Email address of the customer
         */
        public Builder emailAddress(String emailAddress) {
            Utils.checkNotNull(emailAddress, "emailAddress");
            this.emailAddress = Optional.ofNullable(emailAddress);
            return this;
        }
        
        /**
         * Email address of the customer
         */
        public Builder emailAddress(Optional<? extends String> emailAddress) {
            Utils.checkNotNull(emailAddress, "emailAddress");
            this.emailAddress = emailAddress;
            return this;
        }

        /**
         * A unique, persistent identifier for this record
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }
        
        public Builder modifiedDate(Optional<? extends String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Any additional information about the customer
         */
        public Builder note(String note) {
            Utils.checkNotNull(note, "note");
            this.note = Optional.ofNullable(note);
            return this;
        }
        
        /**
         * Any additional information about the customer
         */
        public Builder note(Optional<? extends String> note) {
            Utils.checkNotNull(note, "note");
            this.note = note;
            return this;
        }

        /**
         * A phone number.
         */
        public Builder phone(String phone) {
            Utils.checkNotNull(phone, "phone");
            this.phone = JsonNullable.of(phone);
            return this;
        }

        /**
         * A phone number.
         */
        public Builder phone(JsonNullable<? extends String> phone) {
            Utils.checkNotNull(phone, "phone");
            this.phone = phone;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }
        
        public Builder sourceModifiedDate(Optional<? extends String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }        
        
        public CommerceCustomer build() {
            return new CommerceCustomer(
                addresses,
                createdDate,
                customerName,
                defaultCurrency,
                emailAddress,
                id,
                modifiedDate,
                note,
                phone,
                sourceModifiedDate);
        }
    }
}

