/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package io.codat.lending.models.shared;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * AccountingAccount - ï»¿&gt; **Language tip:** Accounts are also referred to as **chart of accounts**, **nominal accounts**, and **general ledger**.
 * 
 * View the coverage for accounts in the &lt;a className="external" href="https://knowledge.codat.io/supported-features/accounting?view=tab-by-data-type&amp;dataType=chartOfAccounts" target="_blank"&gt;Data coverage explorer&lt;/a&gt;.
 * 
 * ## Overview
 * 
 * Accounts are the categories a business uses to record accounting transactions. From the Accounts endpoints, you can retrieve a list of all accounts for a specified company.
 * 
 * The categories for an account include:
 * * Asset
 * * Expense
 * * Income
 * * Liability
 * * Equity.
 * 
 * The same account may have a different category based on the integration it is used in. For example, a current account (known as checking in the US) should be categorized as `Asset.Current` for Xero, and `Asset.Bank.Checking` for QuickBooks Online.
 * 
 * At the same time, each integration may have its own requirements to the categories. For example, a Paypal account in Xero is of the `Asset.Bank` category and therefore requires additional properties to be provided.
 * 
 * To determine the list of allowed categories for a specific integration, you can:
 * - Follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide and use the [Get create account model](https://docs.codat.io/lending-api#/operations/get-create-chartOfAccounts-model).
 * - Refer to the integration's own documentation.
 * 
 * &gt; **Accounts with no category**
 * &gt;
 * &gt; If an account is pulled from the chart of accounts and its nominal code does not lie within the category layout for the company's accounts, then the **type** is `Unknown`. The **fullyQualifiedCategory** and **fullyQualifiedName** fields return `null`.
 * &gt;
 * &gt; This approach gives a true representation of the company's accounts whilst preventing distorting financials such as a company's profit and loss and balance sheet reports.
 */

public class AccountingAccount {

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<String> currency;

    /**
     * Current balance in the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currentBalance")
    private JsonNullable<? extends BigDecimal> currentBalance;

    /**
     * Description for the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<String> description;

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullyQualifiedCategory")
    private JsonNullable<String> fullyQualifiedCategory;

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fullyQualifiedName")
    private JsonNullable<String> fullyQualifiedName;

    /**
     * Identifier for the account, unique for the company.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Confirms whether the account is a bank account or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isBankAccount")
    private Optional<Boolean> isBankAccount;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private Optional<? extends Metadata> metadata;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<String> modifiedDate;

    /**
     * Name of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private JsonNullable<String> name;

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nominalCode")
    private JsonNullable<String> nominalCode;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<String> sourceModifiedDate;

    /**
     * Status of the account
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends AccountStatus> status;

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplementalData")
    private Optional<? extends SupplementalData> supplementalData;

    /**
     * Type of account
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends AccountType> type;

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("validDatatypeLinks")
    private JsonNullable<? extends List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks;

    @JsonCreator
    public AccountingAccount(
            @JsonProperty("currency") Optional<String> currency,
            @JsonProperty("currentBalance") JsonNullable<? extends BigDecimal> currentBalance,
            @JsonProperty("description") JsonNullable<String> description,
            @JsonProperty("fullyQualifiedCategory") JsonNullable<String> fullyQualifiedCategory,
            @JsonProperty("fullyQualifiedName") JsonNullable<String> fullyQualifiedName,
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("isBankAccount") Optional<Boolean> isBankAccount,
            @JsonProperty("metadata") Optional<? extends Metadata> metadata,
            @JsonProperty("modifiedDate") Optional<String> modifiedDate,
            @JsonProperty("name") JsonNullable<String> name,
            @JsonProperty("nominalCode") JsonNullable<String> nominalCode,
            @JsonProperty("sourceModifiedDate") Optional<String> sourceModifiedDate,
            @JsonProperty("status") Optional<? extends AccountStatus> status,
            @JsonProperty("supplementalData") Optional<? extends SupplementalData> supplementalData,
            @JsonProperty("type") Optional<? extends AccountType> type,
            @JsonProperty("validDatatypeLinks") JsonNullable<? extends List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks) {
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currentBalance, "currentBalance");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(nominalCode, "nominalCode");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(supplementalData, "supplementalData");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.currency = currency;
        this.currentBalance = currentBalance;
        this.description = description;
        this.fullyQualifiedCategory = fullyQualifiedCategory;
        this.fullyQualifiedName = fullyQualifiedName;
        this.id = id;
        this.isBankAccount = isBankAccount;
        this.metadata = metadata;
        this.modifiedDate = modifiedDate;
        this.name = name;
        this.nominalCode = nominalCode;
        this.sourceModifiedDate = sourceModifiedDate;
        this.status = status;
        this.supplementalData = supplementalData;
        this.type = type;
        this.validDatatypeLinks = validDatatypeLinks;
    }
    
    public AccountingAccount() {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined());
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    @JsonIgnore
    public Optional<String> currency() {
        return currency;
    }

    /**
     * Current balance in the account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<BigDecimal> currentBalance() {
        return (JsonNullable<BigDecimal>) currentBalance;
    }

    /**
     * Description for the account.
     */
    @JsonIgnore
    public JsonNullable<String> description() {
        return description;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    @JsonIgnore
    public JsonNullable<String> fullyQualifiedCategory() {
        return fullyQualifiedCategory;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    @JsonIgnore
    public JsonNullable<String> fullyQualifiedName() {
        return fullyQualifiedName;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    @JsonIgnore
    public Optional<Boolean> isBankAccount() {
        return isBankAccount;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Metadata> metadata() {
        return (Optional<Metadata>) metadata;
    }

    @JsonIgnore
    public Optional<String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Name of the account.
     */
    @JsonIgnore
    public JsonNullable<String> name() {
        return name;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    @JsonIgnore
    public JsonNullable<String> nominalCode() {
        return nominalCode;
    }

    @JsonIgnore
    public Optional<String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * Status of the account
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AccountStatus> status() {
        return (Optional<AccountStatus>) status;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SupplementalData> supplementalData() {
        return (Optional<SupplementalData>) supplementalData;
    }

    /**
     * Type of account
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AccountType> type() {
        return (Optional<AccountType>) type;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks() {
        return (JsonNullable<List<AccountingAccountValidDataTypeLinks>>) validDatatypeLinks;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public AccountingAccount withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }

    /**
     * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
     * 
     * ## Unknown currencies
     * 
     * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
     * 
     * There are only a very small number of edge cases where this currency code is returned by the Codat system.
     */
    public AccountingAccount withCurrency(Optional<String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Current balance in the account.
     */
    public AccountingAccount withCurrentBalance(BigDecimal currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = JsonNullable.of(currentBalance);
        return this;
    }

        /**
         * Current balance in the account.
         */
    public AccountingAccount withCurrentBalance(double currentBalance) {
        this.currentBalance = JsonNullable.of(BigDecimal.valueOf(currentBalance));
        return this;
    }

    /**
     * Current balance in the account.
     */
    public AccountingAccount withCurrentBalance(JsonNullable<? extends BigDecimal> currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = currentBalance;
        return this;
    }

    /**
     * Description for the account.
     */
    public AccountingAccount withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = JsonNullable.of(description);
        return this;
    }

    /**
     * Description for the account.
     */
    public AccountingAccount withDescription(JsonNullable<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    public AccountingAccount withFullyQualifiedCategory(String fullyQualifiedCategory) {
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        this.fullyQualifiedCategory = JsonNullable.of(fullyQualifiedCategory);
        return this;
    }

    /**
     * Full category of the account. 
     * 
     * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
     */
    public AccountingAccount withFullyQualifiedCategory(JsonNullable<String> fullyQualifiedCategory) {
        Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
        this.fullyQualifiedCategory = fullyQualifiedCategory;
        return this;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    public AccountingAccount withFullyQualifiedName(String fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
        return this;
    }

    /**
     * Full name of the account, for example:
     * - `Cash On Hand`
     * - `Rents Held In Trust`
     * - `Fixed Asset`
     */
    public AccountingAccount withFullyQualifiedName(JsonNullable<String> fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = fullyQualifiedName;
        return this;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    public AccountingAccount withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * Identifier for the account, unique for the company.
     */
    public AccountingAccount withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    public AccountingAccount withIsBankAccount(boolean isBankAccount) {
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        this.isBankAccount = Optional.ofNullable(isBankAccount);
        return this;
    }

    /**
     * Confirms whether the account is a bank account or not.
     */
    public AccountingAccount withIsBankAccount(Optional<Boolean> isBankAccount) {
        Utils.checkNotNull(isBankAccount, "isBankAccount");
        this.isBankAccount = isBankAccount;
        return this;
    }

    public AccountingAccount withMetadata(Metadata metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = Optional.ofNullable(metadata);
        return this;
    }

    public AccountingAccount withMetadata(Optional<? extends Metadata> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    public AccountingAccount withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }

    public AccountingAccount withModifiedDate(Optional<String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Name of the account.
     */
    public AccountingAccount withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = JsonNullable.of(name);
        return this;
    }

    /**
     * Name of the account.
     */
    public AccountingAccount withName(JsonNullable<String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    public AccountingAccount withNominalCode(String nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = JsonNullable.of(nominalCode);
        return this;
    }

    /**
     * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
     */
    public AccountingAccount withNominalCode(JsonNullable<String> nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = nominalCode;
        return this;
    }

    public AccountingAccount withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }

    public AccountingAccount withSourceModifiedDate(Optional<String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * Status of the account
     */
    public AccountingAccount withStatus(AccountStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * Status of the account
     */
    public AccountingAccount withStatus(Optional<? extends AccountStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public AccountingAccount withSupplementalData(SupplementalData supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = Optional.ofNullable(supplementalData);
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public AccountingAccount withSupplementalData(Optional<? extends SupplementalData> supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = supplementalData;
        return this;
    }

    /**
     * Type of account
     */
    public AccountingAccount withType(AccountType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * Type of account
     */
    public AccountingAccount withType(Optional<? extends AccountType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
     */
    public AccountingAccount withValidDatatypeLinks(List<AccountingAccountValidDataTypeLinks> validDatatypeLinks) {
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.validDatatypeLinks = JsonNullable.of(validDatatypeLinks);
        return this;
    }

    /**
     * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
     */
    public AccountingAccount withValidDatatypeLinks(JsonNullable<? extends List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks) {
        Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
        this.validDatatypeLinks = validDatatypeLinks;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        AccountingAccount other = (AccountingAccount) o;
        return 
            Objects.deepEquals(this.currency, other.currency) &&
            Objects.deepEquals(this.currentBalance, other.currentBalance) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.fullyQualifiedCategory, other.fullyQualifiedCategory) &&
            Objects.deepEquals(this.fullyQualifiedName, other.fullyQualifiedName) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.isBankAccount, other.isBankAccount) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.nominalCode, other.nominalCode) &&
            Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.supplementalData, other.supplementalData) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.validDatatypeLinks, other.validDatatypeLinks);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            currency,
            currentBalance,
            description,
            fullyQualifiedCategory,
            fullyQualifiedName,
            id,
            isBankAccount,
            metadata,
            modifiedDate,
            name,
            nominalCode,
            sourceModifiedDate,
            status,
            supplementalData,
            type,
            validDatatypeLinks);
    }
    
    @Override
    public String toString() {
        return Utils.toString(AccountingAccount.class,
                "currency", currency,
                "currentBalance", currentBalance,
                "description", description,
                "fullyQualifiedCategory", fullyQualifiedCategory,
                "fullyQualifiedName", fullyQualifiedName,
                "id", id,
                "isBankAccount", isBankAccount,
                "metadata", metadata,
                "modifiedDate", modifiedDate,
                "name", name,
                "nominalCode", nominalCode,
                "sourceModifiedDate", sourceModifiedDate,
                "status", status,
                "supplementalData", supplementalData,
                "type", type,
                "validDatatypeLinks", validDatatypeLinks);
    }
    
    public final static class Builder {
 
        private Optional<String> currency = Optional.empty();
 
        private JsonNullable<? extends BigDecimal> currentBalance = JsonNullable.undefined();
 
        private JsonNullable<String> description = JsonNullable.undefined();
 
        private JsonNullable<String> fullyQualifiedCategory = JsonNullable.undefined();
 
        private JsonNullable<String> fullyQualifiedName = JsonNullable.undefined();
 
        private Optional<String> id = Optional.empty();
 
        private Optional<Boolean> isBankAccount = Optional.empty();
 
        private Optional<? extends Metadata> metadata = Optional.empty();
 
        private Optional<String> modifiedDate = Optional.empty();
 
        private JsonNullable<String> name = JsonNullable.undefined();
 
        private JsonNullable<String> nominalCode = JsonNullable.undefined();
 
        private Optional<String> sourceModifiedDate = Optional.empty();
 
        private Optional<? extends AccountStatus> status = Optional.empty();
 
        private Optional<? extends SupplementalData> supplementalData = Optional.empty();
 
        private Optional<? extends AccountType> type = Optional.empty();
 
        private JsonNullable<? extends List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }

        /**
         * The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.
         * 
         * ## Unknown currencies
         * 
         * In line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. 
         * 
         * There are only a very small number of edge cases where this currency code is returned by the Codat system.
         */
        public Builder currency(Optional<String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(BigDecimal currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = JsonNullable.of(currentBalance);
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(double currentBalance) {
            this.currentBalance = JsonNullable.of(BigDecimal.valueOf(currentBalance));
            return this;
        }

        /**
         * Current balance in the account.
         */
        public Builder currentBalance(JsonNullable<? extends BigDecimal> currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = currentBalance;
            return this;
        }

        /**
         * Description for the account.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * Description for the account.
         */
        public Builder description(JsonNullable<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * Full category of the account. 
         * 
         * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
         */
        public Builder fullyQualifiedCategory(String fullyQualifiedCategory) {
            Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
            this.fullyQualifiedCategory = JsonNullable.of(fullyQualifiedCategory);
            return this;
        }

        /**
         * Full category of the account. 
         * 
         * For example, `Liability.Current` or `Income.Revenue`. To determine a list of possible categories for each integration, see our examples, follow our [Create, update, delete data](https://docs.codat.io/using-the-api/push) guide, or refer to the integration's own documentation.
         */
        public Builder fullyQualifiedCategory(JsonNullable<String> fullyQualifiedCategory) {
            Utils.checkNotNull(fullyQualifiedCategory, "fullyQualifiedCategory");
            this.fullyQualifiedCategory = fullyQualifiedCategory;
            return this;
        }

        /**
         * Full name of the account, for example:
         * - `Cash On Hand`
         * - `Rents Held In Trust`
         * - `Fixed Asset`
         */
        public Builder fullyQualifiedName(String fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
            return this;
        }

        /**
         * Full name of the account, for example:
         * - `Cash On Hand`
         * - `Rents Held In Trust`
         * - `Fixed Asset`
         */
        public Builder fullyQualifiedName(JsonNullable<String> fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = fullyQualifiedName;
            return this;
        }

        /**
         * Identifier for the account, unique for the company.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * Identifier for the account, unique for the company.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Confirms whether the account is a bank account or not.
         */
        public Builder isBankAccount(boolean isBankAccount) {
            Utils.checkNotNull(isBankAccount, "isBankAccount");
            this.isBankAccount = Optional.ofNullable(isBankAccount);
            return this;
        }

        /**
         * Confirms whether the account is a bank account or not.
         */
        public Builder isBankAccount(Optional<Boolean> isBankAccount) {
            Utils.checkNotNull(isBankAccount, "isBankAccount");
            this.isBankAccount = isBankAccount;
            return this;
        }

        public Builder metadata(Metadata metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = Optional.ofNullable(metadata);
            return this;
        }

        public Builder metadata(Optional<? extends Metadata> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }

        public Builder modifiedDate(Optional<String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Name of the account.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = JsonNullable.of(name);
            return this;
        }

        /**
         * Name of the account.
         */
        public Builder name(JsonNullable<String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
         */
        public Builder nominalCode(String nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = JsonNullable.of(nominalCode);
            return this;
        }

        /**
         * Reference given to each nominal account for a business. It ensures money is allocated to the correct account. This code isn't a unique identifier in the Codat system.
         */
        public Builder nominalCode(JsonNullable<String> nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = nominalCode;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }

        public Builder sourceModifiedDate(Optional<String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * Status of the account
         */
        public Builder status(AccountStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Status of the account
         */
        public Builder status(Optional<? extends AccountStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(SupplementalData supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = Optional.ofNullable(supplementalData);
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(Optional<? extends SupplementalData> supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = supplementalData;
            return this;
        }

        /**
         * Type of account
         */
        public Builder type(AccountType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * Type of account
         */
        public Builder type(Optional<? extends AccountType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
         */
        public Builder validDatatypeLinks(List<AccountingAccountValidDataTypeLinks> validDatatypeLinks) {
            Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
            this.validDatatypeLinks = JsonNullable.of(validDatatypeLinks);
            return this;
        }

        /**
         * The validDatatypeLinks can be used to determine whether an account can be correctly mapped to another object; for example, accounts with a `type` of `income` might only support being used on an Invoice and Direct Income. For more information, see [Valid Data Type Links](/lending-api#/schemas/ValidDataTypeLinks).
         */
        public Builder validDatatypeLinks(JsonNullable<? extends List<AccountingAccountValidDataTypeLinks>> validDatatypeLinks) {
            Utils.checkNotNull(validDatatypeLinks, "validDatatypeLinks");
            this.validDatatypeLinks = validDatatypeLinks;
            return this;
        }
        
        public AccountingAccount build() {
            return new AccountingAccount(
                currency,
                currentBalance,
                description,
                fullyQualifiedCategory,
                fullyQualifiedName,
                id,
                isBankAccount,
                metadata,
                modifiedDate,
                name,
                nominalCode,
                sourceModifiedDate,
                status,
                supplementalData,
                type,
                validDatatypeLinks);
        }
    }
}

