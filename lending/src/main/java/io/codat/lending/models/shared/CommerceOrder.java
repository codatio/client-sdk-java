/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package io.codat.lending.models.shared;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * CommerceOrder - Orders contain the transaction details for all products sold by the company, and include details of any payments, service charges, or refunds related to each order. You can use data from the Orders endpoints to calculate key metrics, such as gross sales values and monthly recurring revenue (MRR).
 * 
 * Explore our [data coverage](https://knowledge.codat.io/supported-features/commerce?view=tab-by-data-type&amp;dataType=commerce-orders) for this data type.
 * 
 */

public class CommerceOrder {

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("closedDate")
    private Optional<String> closedDate;

    /**
     * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
     * 
     * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
     * 
     * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("country")
    private Optional<String> country;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdDate")
    private Optional<String> createdDate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<String> currency;

    /**
     * Reference to the customer that placed the order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerRef")
    private Optional<? extends CommerceCustomerRef> customerRef;

    /**
     * A unique, persistent identifier for this record
     */
    @JsonProperty("id")
    private String id;

    /**
     * Reference to the geographic location where the order was placed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locationRef")
    private Optional<? extends LocationRef> locationRef;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<String> modifiedDate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderLineItems")
    private Optional<? extends List<OrderLineItem>> orderLineItems;

    /**
     * Friendly reference for the order in the commerce or point of sale platform.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("orderNumber")
    private Optional<String> orderNumber;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payments")
    private Optional<? extends List<PaymentRef>> payments;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("serviceCharges")
    private Optional<? extends List<ServiceCharge>> serviceCharges;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<String> sourceModifiedDate;

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplementalData")
    private Optional<? extends SupplementalData> supplementalData;

    /**
     * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalAmount")
    private Optional<? extends BigDecimal> totalAmount;

    /**
     * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalDiscount")
    private Optional<? extends BigDecimal> totalDiscount;

    /**
     * Extra amount added to the order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalGratuity")
    private Optional<? extends BigDecimal> totalGratuity;

    /**
     * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalRefund")
    private Optional<? extends BigDecimal> totalRefund;

    /**
     * Total amount of tax applied to the order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("totalTaxAmount")
    private Optional<? extends BigDecimal> totalTaxAmount;

    @JsonCreator
    public CommerceOrder(
            @JsonProperty("closedDate") Optional<String> closedDate,
            @JsonProperty("country") Optional<String> country,
            @JsonProperty("createdDate") Optional<String> createdDate,
            @JsonProperty("currency") Optional<String> currency,
            @JsonProperty("customerRef") Optional<? extends CommerceCustomerRef> customerRef,
            @JsonProperty("id") String id,
            @JsonProperty("locationRef") Optional<? extends LocationRef> locationRef,
            @JsonProperty("modifiedDate") Optional<String> modifiedDate,
            @JsonProperty("orderLineItems") Optional<? extends List<OrderLineItem>> orderLineItems,
            @JsonProperty("orderNumber") Optional<String> orderNumber,
            @JsonProperty("payments") Optional<? extends List<PaymentRef>> payments,
            @JsonProperty("serviceCharges") Optional<? extends List<ServiceCharge>> serviceCharges,
            @JsonProperty("sourceModifiedDate") Optional<String> sourceModifiedDate,
            @JsonProperty("supplementalData") Optional<? extends SupplementalData> supplementalData,
            @JsonProperty("totalAmount") Optional<? extends BigDecimal> totalAmount,
            @JsonProperty("totalDiscount") Optional<? extends BigDecimal> totalDiscount,
            @JsonProperty("totalGratuity") Optional<? extends BigDecimal> totalGratuity,
            @JsonProperty("totalRefund") Optional<? extends BigDecimal> totalRefund,
            @JsonProperty("totalTaxAmount") Optional<? extends BigDecimal> totalTaxAmount) {
        Utils.checkNotNull(closedDate, "closedDate");
        Utils.checkNotNull(country, "country");
        Utils.checkNotNull(createdDate, "createdDate");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(customerRef, "customerRef");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(locationRef, "locationRef");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(orderLineItems, "orderLineItems");
        Utils.checkNotNull(orderNumber, "orderNumber");
        Utils.checkNotNull(payments, "payments");
        Utils.checkNotNull(serviceCharges, "serviceCharges");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        Utils.checkNotNull(supplementalData, "supplementalData");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        Utils.checkNotNull(totalGratuity, "totalGratuity");
        Utils.checkNotNull(totalRefund, "totalRefund");
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.closedDate = closedDate;
        this.country = country;
        this.createdDate = createdDate;
        this.currency = currency;
        this.customerRef = customerRef;
        this.id = id;
        this.locationRef = locationRef;
        this.modifiedDate = modifiedDate;
        this.orderLineItems = orderLineItems;
        this.orderNumber = orderNumber;
        this.payments = payments;
        this.serviceCharges = serviceCharges;
        this.sourceModifiedDate = sourceModifiedDate;
        this.supplementalData = supplementalData;
        this.totalAmount = totalAmount;
        this.totalDiscount = totalDiscount;
        this.totalGratuity = totalGratuity;
        this.totalRefund = totalRefund;
        this.totalTaxAmount = totalTaxAmount;
    }
    
    public CommerceOrder(
            String id) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), id, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonIgnore
    public Optional<String> closedDate() {
        return closedDate;
    }

    /**
     * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
     * 
     * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
     * 
     * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
     */
    @JsonIgnore
    public Optional<String> country() {
        return country;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonIgnore
    public Optional<String> createdDate() {
        return createdDate;
    }

    @JsonIgnore
    public Optional<String> currency() {
        return currency;
    }

    /**
     * Reference to the customer that placed the order.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CommerceCustomerRef> customerRef() {
        return (Optional<CommerceCustomerRef>) customerRef;
    }

    /**
     * A unique, persistent identifier for this record
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Reference to the geographic location where the order was placed.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LocationRef> locationRef() {
        return (Optional<LocationRef>) locationRef;
    }

    @JsonIgnore
    public Optional<String> modifiedDate() {
        return modifiedDate;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<OrderLineItem>> orderLineItems() {
        return (Optional<List<OrderLineItem>>) orderLineItems;
    }

    /**
     * Friendly reference for the order in the commerce or point of sale platform.
     */
    @JsonIgnore
    public Optional<String> orderNumber() {
        return orderNumber;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PaymentRef>> payments() {
        return (Optional<List<PaymentRef>>) payments;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ServiceCharge>> serviceCharges() {
        return (Optional<List<ServiceCharge>>) serviceCharges;
    }

    @JsonIgnore
    public Optional<String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<SupplementalData> supplementalData() {
        return (Optional<SupplementalData>) supplementalData;
    }

    /**
     * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BigDecimal> totalAmount() {
        return (Optional<BigDecimal>) totalAmount;
    }

    /**
     * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BigDecimal> totalDiscount() {
        return (Optional<BigDecimal>) totalDiscount;
    }

    /**
     * Extra amount added to the order.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BigDecimal> totalGratuity() {
        return (Optional<BigDecimal>) totalGratuity;
    }

    /**
     * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BigDecimal> totalRefund() {
        return (Optional<BigDecimal>) totalRefund;
    }

    /**
     * Total amount of tax applied to the order.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BigDecimal> totalTaxAmount() {
        return (Optional<BigDecimal>) totalTaxAmount;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceOrder withClosedDate(String closedDate) {
        Utils.checkNotNull(closedDate, "closedDate");
        this.closedDate = Optional.ofNullable(closedDate);
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceOrder withClosedDate(Optional<String> closedDate) {
        Utils.checkNotNull(closedDate, "closedDate");
        this.closedDate = closedDate;
        return this;
    }

    /**
     * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
     * 
     * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
     * 
     * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
     */
    public CommerceOrder withCountry(String country) {
        Utils.checkNotNull(country, "country");
        this.country = Optional.ofNullable(country);
        return this;
    }

    /**
     * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
     * 
     * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
     * 
     * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
     */
    public CommerceOrder withCountry(Optional<String> country) {
        Utils.checkNotNull(country, "country");
        this.country = country;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceOrder withCreatedDate(String createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = Optional.ofNullable(createdDate);
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceOrder withCreatedDate(Optional<String> createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = createdDate;
        return this;
    }

    public CommerceOrder withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }

    public CommerceOrder withCurrency(Optional<String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Reference to the customer that placed the order.
     */
    public CommerceOrder withCustomerRef(CommerceCustomerRef customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = Optional.ofNullable(customerRef);
        return this;
    }

    /**
     * Reference to the customer that placed the order.
     */
    public CommerceOrder withCustomerRef(Optional<? extends CommerceCustomerRef> customerRef) {
        Utils.checkNotNull(customerRef, "customerRef");
        this.customerRef = customerRef;
        return this;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public CommerceOrder withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Reference to the geographic location where the order was placed.
     */
    public CommerceOrder withLocationRef(LocationRef locationRef) {
        Utils.checkNotNull(locationRef, "locationRef");
        this.locationRef = Optional.ofNullable(locationRef);
        return this;
    }

    /**
     * Reference to the geographic location where the order was placed.
     */
    public CommerceOrder withLocationRef(Optional<? extends LocationRef> locationRef) {
        Utils.checkNotNull(locationRef, "locationRef");
        this.locationRef = locationRef;
        return this;
    }

    public CommerceOrder withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }

    public CommerceOrder withModifiedDate(Optional<String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    public CommerceOrder withOrderLineItems(List<OrderLineItem> orderLineItems) {
        Utils.checkNotNull(orderLineItems, "orderLineItems");
        this.orderLineItems = Optional.ofNullable(orderLineItems);
        return this;
    }

    public CommerceOrder withOrderLineItems(Optional<? extends List<OrderLineItem>> orderLineItems) {
        Utils.checkNotNull(orderLineItems, "orderLineItems");
        this.orderLineItems = orderLineItems;
        return this;
    }

    /**
     * Friendly reference for the order in the commerce or point of sale platform.
     */
    public CommerceOrder withOrderNumber(String orderNumber) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        this.orderNumber = Optional.ofNullable(orderNumber);
        return this;
    }

    /**
     * Friendly reference for the order in the commerce or point of sale platform.
     */
    public CommerceOrder withOrderNumber(Optional<String> orderNumber) {
        Utils.checkNotNull(orderNumber, "orderNumber");
        this.orderNumber = orderNumber;
        return this;
    }

    public CommerceOrder withPayments(List<PaymentRef> payments) {
        Utils.checkNotNull(payments, "payments");
        this.payments = Optional.ofNullable(payments);
        return this;
    }

    public CommerceOrder withPayments(Optional<? extends List<PaymentRef>> payments) {
        Utils.checkNotNull(payments, "payments");
        this.payments = payments;
        return this;
    }

    public CommerceOrder withServiceCharges(List<ServiceCharge> serviceCharges) {
        Utils.checkNotNull(serviceCharges, "serviceCharges");
        this.serviceCharges = Optional.ofNullable(serviceCharges);
        return this;
    }

    public CommerceOrder withServiceCharges(Optional<? extends List<ServiceCharge>> serviceCharges) {
        Utils.checkNotNull(serviceCharges, "serviceCharges");
        this.serviceCharges = serviceCharges;
        return this;
    }

    public CommerceOrder withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }

    public CommerceOrder withSourceModifiedDate(Optional<String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public CommerceOrder withSupplementalData(SupplementalData supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = Optional.ofNullable(supplementalData);
        return this;
    }

    /**
     * Supplemental data is additional data you can include in our standard data types. 
     * 
     * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
     */
    public CommerceOrder withSupplementalData(Optional<? extends SupplementalData> supplementalData) {
        Utils.checkNotNull(supplementalData, "supplementalData");
        this.supplementalData = supplementalData;
        return this;
    }

    /**
     * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
     */
    public CommerceOrder withTotalAmount(BigDecimal totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = Optional.ofNullable(totalAmount);
        return this;
    }

        /**
         * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
         */
    public CommerceOrder withTotalAmount(double totalAmount) {
        this.totalAmount = Optional.of(BigDecimal.valueOf(totalAmount));
        return this;
    }

    /**
     * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
     */
    public CommerceOrder withTotalAmount(Optional<? extends BigDecimal> totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
     */
    public CommerceOrder withTotalDiscount(BigDecimal totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = Optional.ofNullable(totalDiscount);
        return this;
    }

        /**
         * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
         */
    public CommerceOrder withTotalDiscount(double totalDiscount) {
        this.totalDiscount = Optional.of(BigDecimal.valueOf(totalDiscount));
        return this;
    }

    /**
     * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
     */
    public CommerceOrder withTotalDiscount(Optional<? extends BigDecimal> totalDiscount) {
        Utils.checkNotNull(totalDiscount, "totalDiscount");
        this.totalDiscount = totalDiscount;
        return this;
    }

    /**
     * Extra amount added to the order.
     */
    public CommerceOrder withTotalGratuity(BigDecimal totalGratuity) {
        Utils.checkNotNull(totalGratuity, "totalGratuity");
        this.totalGratuity = Optional.ofNullable(totalGratuity);
        return this;
    }

        /**
         * Extra amount added to the order.
         */
    public CommerceOrder withTotalGratuity(double totalGratuity) {
        this.totalGratuity = Optional.of(BigDecimal.valueOf(totalGratuity));
        return this;
    }

    /**
     * Extra amount added to the order.
     */
    public CommerceOrder withTotalGratuity(Optional<? extends BigDecimal> totalGratuity) {
        Utils.checkNotNull(totalGratuity, "totalGratuity");
        this.totalGratuity = totalGratuity;
        return this;
    }

    /**
     * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
     */
    public CommerceOrder withTotalRefund(BigDecimal totalRefund) {
        Utils.checkNotNull(totalRefund, "totalRefund");
        this.totalRefund = Optional.ofNullable(totalRefund);
        return this;
    }

        /**
         * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
         */
    public CommerceOrder withTotalRefund(double totalRefund) {
        this.totalRefund = Optional.of(BigDecimal.valueOf(totalRefund));
        return this;
    }

    /**
     * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
     */
    public CommerceOrder withTotalRefund(Optional<? extends BigDecimal> totalRefund) {
        Utils.checkNotNull(totalRefund, "totalRefund");
        this.totalRefund = totalRefund;
        return this;
    }

    /**
     * Total amount of tax applied to the order.
     */
    public CommerceOrder withTotalTaxAmount(BigDecimal totalTaxAmount) {
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.totalTaxAmount = Optional.ofNullable(totalTaxAmount);
        return this;
    }

        /**
         * Total amount of tax applied to the order.
         */
    public CommerceOrder withTotalTaxAmount(double totalTaxAmount) {
        this.totalTaxAmount = Optional.of(BigDecimal.valueOf(totalTaxAmount));
        return this;
    }

    /**
     * Total amount of tax applied to the order.
     */
    public CommerceOrder withTotalTaxAmount(Optional<? extends BigDecimal> totalTaxAmount) {
        Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
        this.totalTaxAmount = totalTaxAmount;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CommerceOrder other = (CommerceOrder) o;
        return 
            Objects.deepEquals(this.closedDate, other.closedDate) &&
            Objects.deepEquals(this.country, other.country) &&
            Objects.deepEquals(this.createdDate, other.createdDate) &&
            Objects.deepEquals(this.currency, other.currency) &&
            Objects.deepEquals(this.customerRef, other.customerRef) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.locationRef, other.locationRef) &&
            Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            Objects.deepEquals(this.orderLineItems, other.orderLineItems) &&
            Objects.deepEquals(this.orderNumber, other.orderNumber) &&
            Objects.deepEquals(this.payments, other.payments) &&
            Objects.deepEquals(this.serviceCharges, other.serviceCharges) &&
            Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate) &&
            Objects.deepEquals(this.supplementalData, other.supplementalData) &&
            Objects.deepEquals(this.totalAmount, other.totalAmount) &&
            Objects.deepEquals(this.totalDiscount, other.totalDiscount) &&
            Objects.deepEquals(this.totalGratuity, other.totalGratuity) &&
            Objects.deepEquals(this.totalRefund, other.totalRefund) &&
            Objects.deepEquals(this.totalTaxAmount, other.totalTaxAmount);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            closedDate,
            country,
            createdDate,
            currency,
            customerRef,
            id,
            locationRef,
            modifiedDate,
            orderLineItems,
            orderNumber,
            payments,
            serviceCharges,
            sourceModifiedDate,
            supplementalData,
            totalAmount,
            totalDiscount,
            totalGratuity,
            totalRefund,
            totalTaxAmount);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CommerceOrder.class,
                "closedDate", closedDate,
                "country", country,
                "createdDate", createdDate,
                "currency", currency,
                "customerRef", customerRef,
                "id", id,
                "locationRef", locationRef,
                "modifiedDate", modifiedDate,
                "orderLineItems", orderLineItems,
                "orderNumber", orderNumber,
                "payments", payments,
                "serviceCharges", serviceCharges,
                "sourceModifiedDate", sourceModifiedDate,
                "supplementalData", supplementalData,
                "totalAmount", totalAmount,
                "totalDiscount", totalDiscount,
                "totalGratuity", totalGratuity,
                "totalRefund", totalRefund,
                "totalTaxAmount", totalTaxAmount);
    }
    
    public final static class Builder {
 
        private Optional<String> closedDate = Optional.empty();
 
        private Optional<String> country = Optional.empty();
 
        private Optional<String> createdDate = Optional.empty();
 
        private Optional<String> currency = Optional.empty();
 
        private Optional<? extends CommerceCustomerRef> customerRef = Optional.empty();
 
        private String id;
 
        private Optional<? extends LocationRef> locationRef = Optional.empty();
 
        private Optional<String> modifiedDate = Optional.empty();
 
        private Optional<? extends List<OrderLineItem>> orderLineItems = Optional.empty();
 
        private Optional<String> orderNumber = Optional.empty();
 
        private Optional<? extends List<PaymentRef>> payments = Optional.empty();
 
        private Optional<? extends List<ServiceCharge>> serviceCharges = Optional.empty();
 
        private Optional<String> sourceModifiedDate = Optional.empty();
 
        private Optional<? extends SupplementalData> supplementalData = Optional.empty();
 
        private Optional<? extends BigDecimal> totalAmount = Optional.empty();
 
        private Optional<? extends BigDecimal> totalDiscount = Optional.empty();
 
        private Optional<? extends BigDecimal> totalGratuity = Optional.empty();
 
        private Optional<? extends BigDecimal> totalRefund = Optional.empty();
 
        private Optional<? extends BigDecimal> totalTaxAmount = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder closedDate(String closedDate) {
            Utils.checkNotNull(closedDate, "closedDate");
            this.closedDate = Optional.ofNullable(closedDate);
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder closedDate(Optional<String> closedDate) {
            Utils.checkNotNull(closedDate, "closedDate");
            this.closedDate = closedDate;
            return this;
        }

        /**
         * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
         * 
         * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
         * 
         * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
         */
        public Builder country(String country) {
            Utils.checkNotNull(country, "country");
            this.country = Optional.ofNullable(country);
            return this;
        }

        /**
         * The Codat country property is returned as it was provided in the underlying platform by the company without any formatting on our part.
         * 
         * Depending on the platform the value of this property will either be an &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes" target="_blank"&gt;ISO 3166&lt;/a&gt; code (2-alpha or 3-alpha) or free-form text returned as a string name in our model. 
         * 
         * For POST operations against platforms that demand a specific format for the country code, we have documented accepted values in the [options](https://docs.codat.io/lending-api#/operations/get-companies-companyId-connections-connectionId-push) endpoint.
         */
        public Builder country(Optional<String> country) {
            Utils.checkNotNull(country, "country");
            this.country = country;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(String createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = Optional.ofNullable(createdDate);
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(Optional<String> createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = createdDate;
            return this;
        }

        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }

        public Builder currency(Optional<String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Reference to the customer that placed the order.
         */
        public Builder customerRef(CommerceCustomerRef customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = Optional.ofNullable(customerRef);
            return this;
        }

        /**
         * Reference to the customer that placed the order.
         */
        public Builder customerRef(Optional<? extends CommerceCustomerRef> customerRef) {
            Utils.checkNotNull(customerRef, "customerRef");
            this.customerRef = customerRef;
            return this;
        }

        /**
         * A unique, persistent identifier for this record
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Reference to the geographic location where the order was placed.
         */
        public Builder locationRef(LocationRef locationRef) {
            Utils.checkNotNull(locationRef, "locationRef");
            this.locationRef = Optional.ofNullable(locationRef);
            return this;
        }

        /**
         * Reference to the geographic location where the order was placed.
         */
        public Builder locationRef(Optional<? extends LocationRef> locationRef) {
            Utils.checkNotNull(locationRef, "locationRef");
            this.locationRef = locationRef;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }

        public Builder modifiedDate(Optional<String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        public Builder orderLineItems(List<OrderLineItem> orderLineItems) {
            Utils.checkNotNull(orderLineItems, "orderLineItems");
            this.orderLineItems = Optional.ofNullable(orderLineItems);
            return this;
        }

        public Builder orderLineItems(Optional<? extends List<OrderLineItem>> orderLineItems) {
            Utils.checkNotNull(orderLineItems, "orderLineItems");
            this.orderLineItems = orderLineItems;
            return this;
        }

        /**
         * Friendly reference for the order in the commerce or point of sale platform.
         */
        public Builder orderNumber(String orderNumber) {
            Utils.checkNotNull(orderNumber, "orderNumber");
            this.orderNumber = Optional.ofNullable(orderNumber);
            return this;
        }

        /**
         * Friendly reference for the order in the commerce or point of sale platform.
         */
        public Builder orderNumber(Optional<String> orderNumber) {
            Utils.checkNotNull(orderNumber, "orderNumber");
            this.orderNumber = orderNumber;
            return this;
        }

        public Builder payments(List<PaymentRef> payments) {
            Utils.checkNotNull(payments, "payments");
            this.payments = Optional.ofNullable(payments);
            return this;
        }

        public Builder payments(Optional<? extends List<PaymentRef>> payments) {
            Utils.checkNotNull(payments, "payments");
            this.payments = payments;
            return this;
        }

        public Builder serviceCharges(List<ServiceCharge> serviceCharges) {
            Utils.checkNotNull(serviceCharges, "serviceCharges");
            this.serviceCharges = Optional.ofNullable(serviceCharges);
            return this;
        }

        public Builder serviceCharges(Optional<? extends List<ServiceCharge>> serviceCharges) {
            Utils.checkNotNull(serviceCharges, "serviceCharges");
            this.serviceCharges = serviceCharges;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }

        public Builder sourceModifiedDate(Optional<String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(SupplementalData supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = Optional.ofNullable(supplementalData);
            return this;
        }

        /**
         * Supplemental data is additional data you can include in our standard data types. 
         * 
         * It is referenced as a configured dynamic key value pair that is unique to the accounting software. [Learn more](https://docs.codat.io/using-the-api/supplemental-data/overview) about supplemental data.
         */
        public Builder supplementalData(Optional<? extends SupplementalData> supplementalData) {
            Utils.checkNotNull(supplementalData, "supplementalData");
            this.supplementalData = supplementalData;
            return this;
        }

        /**
         * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
         */
        public Builder totalAmount(BigDecimal totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = Optional.ofNullable(totalAmount);
            return this;
        }

        /**
         * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
         */
        public Builder totalAmount(double totalAmount) {
            this.totalAmount = Optional.of(BigDecimal.valueOf(totalAmount));
            return this;
        }

        /**
         * Total amount of the order, including discounts, refunds, and tax, but excluding gratuities.
         */
        public Builder totalAmount(Optional<? extends BigDecimal> totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }

        /**
         * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
         */
        public Builder totalDiscount(BigDecimal totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = Optional.ofNullable(totalDiscount);
            return this;
        }

        /**
         * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
         */
        public Builder totalDiscount(double totalDiscount) {
            this.totalDiscount = Optional.of(BigDecimal.valueOf(totalDiscount));
            return this;
        }

        /**
         * Total amount of any discounts applied to the order, excluding tax. This is typically positive (for discounts which decrease the amount of the order), but can also be negative (for discounts which increase the amount of the order).
         */
        public Builder totalDiscount(Optional<? extends BigDecimal> totalDiscount) {
            Utils.checkNotNull(totalDiscount, "totalDiscount");
            this.totalDiscount = totalDiscount;
            return this;
        }

        /**
         * Extra amount added to the order.
         */
        public Builder totalGratuity(BigDecimal totalGratuity) {
            Utils.checkNotNull(totalGratuity, "totalGratuity");
            this.totalGratuity = Optional.ofNullable(totalGratuity);
            return this;
        }

        /**
         * Extra amount added to the order.
         */
        public Builder totalGratuity(double totalGratuity) {
            this.totalGratuity = Optional.of(BigDecimal.valueOf(totalGratuity));
            return this;
        }

        /**
         * Extra amount added to the order.
         */
        public Builder totalGratuity(Optional<? extends BigDecimal> totalGratuity) {
            Utils.checkNotNull(totalGratuity, "totalGratuity");
            this.totalGratuity = totalGratuity;
            return this;
        }

        /**
         * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
         */
        public Builder totalRefund(BigDecimal totalRefund) {
            Utils.checkNotNull(totalRefund, "totalRefund");
            this.totalRefund = Optional.ofNullable(totalRefund);
            return this;
        }

        /**
         * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
         */
        public Builder totalRefund(double totalRefund) {
            this.totalRefund = Optional.of(BigDecimal.valueOf(totalRefund));
            return this;
        }

        /**
         * Total amount of any refunds issued on the order, including discounts and tax, but excluding gratuities. This is always negative.
         */
        public Builder totalRefund(Optional<? extends BigDecimal> totalRefund) {
            Utils.checkNotNull(totalRefund, "totalRefund");
            this.totalRefund = totalRefund;
            return this;
        }

        /**
         * Total amount of tax applied to the order.
         */
        public Builder totalTaxAmount(BigDecimal totalTaxAmount) {
            Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
            this.totalTaxAmount = Optional.ofNullable(totalTaxAmount);
            return this;
        }

        /**
         * Total amount of tax applied to the order.
         */
        public Builder totalTaxAmount(double totalTaxAmount) {
            this.totalTaxAmount = Optional.of(BigDecimal.valueOf(totalTaxAmount));
            return this;
        }

        /**
         * Total amount of tax applied to the order.
         */
        public Builder totalTaxAmount(Optional<? extends BigDecimal> totalTaxAmount) {
            Utils.checkNotNull(totalTaxAmount, "totalTaxAmount");
            this.totalTaxAmount = totalTaxAmount;
            return this;
        }
        
        public CommerceOrder build() {
            return new CommerceOrder(
                closedDate,
                country,
                createdDate,
                currency,
                customerRef,
                id,
                locationRef,
                modifiedDate,
                orderLineItems,
                orderNumber,
                payments,
                serviceCharges,
                sourceModifiedDate,
                supplementalData,
                totalAmount,
                totalDiscount,
                totalGratuity,
                totalRefund,
                totalTaxAmount);
        }
    }
}

