/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package io.codat.lending.models.shared;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.math.BigDecimal;
import java.util.Objects;
import java.util.Optional;


public class ProfitAndLossReport {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("costOfSales")
    private Optional<? extends ReportLine> costOfSales;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expenses")
    private Optional<? extends ReportLine> expenses;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fromDate")
    private Optional<String> fromDate;

    /**
     * Gross profit of the company in the given date range.
     */
    @JsonProperty("grossProfit")
    private BigDecimal grossProfit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("income")
    private Optional<? extends ReportLine> income;

    /**
     * Net operating profit of the company in the given date range.
     */
    @JsonProperty("netOperatingProfit")
    private BigDecimal netOperatingProfit;

    /**
     * Net other income of the company in the given date range.
     */
    @JsonProperty("netOtherIncome")
    private BigDecimal netOtherIncome;

    /**
     * Net profit of the company in the given date range.
     */
    @JsonProperty("netProfit")
    private BigDecimal netProfit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("otherExpenses")
    private Optional<? extends ReportLine> otherExpenses;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("otherIncome")
    private Optional<? extends ReportLine> otherIncome;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("toDate")
    private Optional<String> toDate;

    @JsonCreator
    public ProfitAndLossReport(
            @JsonProperty("costOfSales") Optional<? extends ReportLine> costOfSales,
            @JsonProperty("expenses") Optional<? extends ReportLine> expenses,
            @JsonProperty("fromDate") Optional<String> fromDate,
            @JsonProperty("grossProfit") BigDecimal grossProfit,
            @JsonProperty("income") Optional<? extends ReportLine> income,
            @JsonProperty("netOperatingProfit") BigDecimal netOperatingProfit,
            @JsonProperty("netOtherIncome") BigDecimal netOtherIncome,
            @JsonProperty("netProfit") BigDecimal netProfit,
            @JsonProperty("otherExpenses") Optional<? extends ReportLine> otherExpenses,
            @JsonProperty("otherIncome") Optional<? extends ReportLine> otherIncome,
            @JsonProperty("toDate") Optional<String> toDate) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        Utils.checkNotNull(expenses, "expenses");
        Utils.checkNotNull(fromDate, "fromDate");
        Utils.checkNotNull(grossProfit, "grossProfit");
        Utils.checkNotNull(income, "income");
        Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
        Utils.checkNotNull(netOtherIncome, "netOtherIncome");
        Utils.checkNotNull(netProfit, "netProfit");
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        Utils.checkNotNull(otherIncome, "otherIncome");
        Utils.checkNotNull(toDate, "toDate");
        this.costOfSales = costOfSales;
        this.expenses = expenses;
        this.fromDate = fromDate;
        this.grossProfit = grossProfit;
        this.income = income;
        this.netOperatingProfit = netOperatingProfit;
        this.netOtherIncome = netOtherIncome;
        this.netProfit = netProfit;
        this.otherExpenses = otherExpenses;
        this.otherIncome = otherIncome;
        this.toDate = toDate;
    }
    
    public ProfitAndLossReport(
            BigDecimal grossProfit,
            BigDecimal netOperatingProfit,
            BigDecimal netOtherIncome,
            BigDecimal netProfit) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), grossProfit, Optional.empty(), netOperatingProfit, netOtherIncome, netProfit, Optional.empty(), Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ReportLine> costOfSales() {
        return (Optional<ReportLine>) costOfSales;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ReportLine> expenses() {
        return (Optional<ReportLine>) expenses;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonIgnore
    public Optional<String> fromDate() {
        return fromDate;
    }

    /**
     * Gross profit of the company in the given date range.
     */
    @JsonIgnore
    public BigDecimal grossProfit() {
        return grossProfit;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ReportLine> income() {
        return (Optional<ReportLine>) income;
    }

    /**
     * Net operating profit of the company in the given date range.
     */
    @JsonIgnore
    public BigDecimal netOperatingProfit() {
        return netOperatingProfit;
    }

    /**
     * Net other income of the company in the given date range.
     */
    @JsonIgnore
    public BigDecimal netOtherIncome() {
        return netOtherIncome;
    }

    /**
     * Net profit of the company in the given date range.
     */
    @JsonIgnore
    public BigDecimal netProfit() {
        return netProfit;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ReportLine> otherExpenses() {
        return (Optional<ReportLine>) otherExpenses;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ReportLine> otherIncome() {
        return (Optional<ReportLine>) otherIncome;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonIgnore
    public Optional<String> toDate() {
        return toDate;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public ProfitAndLossReport withCostOfSales(ReportLine costOfSales) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        this.costOfSales = Optional.ofNullable(costOfSales);
        return this;
    }

    public ProfitAndLossReport withCostOfSales(Optional<? extends ReportLine> costOfSales) {
        Utils.checkNotNull(costOfSales, "costOfSales");
        this.costOfSales = costOfSales;
        return this;
    }

    public ProfitAndLossReport withExpenses(ReportLine expenses) {
        Utils.checkNotNull(expenses, "expenses");
        this.expenses = Optional.ofNullable(expenses);
        return this;
    }

    public ProfitAndLossReport withExpenses(Optional<? extends ReportLine> expenses) {
        Utils.checkNotNull(expenses, "expenses");
        this.expenses = expenses;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withFromDate(String fromDate) {
        Utils.checkNotNull(fromDate, "fromDate");
        this.fromDate = Optional.ofNullable(fromDate);
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withFromDate(Optional<String> fromDate) {
        Utils.checkNotNull(fromDate, "fromDate");
        this.fromDate = fromDate;
        return this;
    }

        /**
         * Gross profit of the company in the given date range.
         */
    public ProfitAndLossReport withGrossProfit(double grossProfit) {
        this.grossProfit = BigDecimal.valueOf(grossProfit);
        return this;
    }

    /**
     * Gross profit of the company in the given date range.
     */
    public ProfitAndLossReport withGrossProfit(BigDecimal grossProfit) {
        Utils.checkNotNull(grossProfit, "grossProfit");
        this.grossProfit = grossProfit;
        return this;
    }

    public ProfitAndLossReport withIncome(ReportLine income) {
        Utils.checkNotNull(income, "income");
        this.income = Optional.ofNullable(income);
        return this;
    }

    public ProfitAndLossReport withIncome(Optional<? extends ReportLine> income) {
        Utils.checkNotNull(income, "income");
        this.income = income;
        return this;
    }

        /**
         * Net operating profit of the company in the given date range.
         */
    public ProfitAndLossReport withNetOperatingProfit(double netOperatingProfit) {
        this.netOperatingProfit = BigDecimal.valueOf(netOperatingProfit);
        return this;
    }

    /**
     * Net operating profit of the company in the given date range.
     */
    public ProfitAndLossReport withNetOperatingProfit(BigDecimal netOperatingProfit) {
        Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
        this.netOperatingProfit = netOperatingProfit;
        return this;
    }

        /**
         * Net other income of the company in the given date range.
         */
    public ProfitAndLossReport withNetOtherIncome(double netOtherIncome) {
        this.netOtherIncome = BigDecimal.valueOf(netOtherIncome);
        return this;
    }

    /**
     * Net other income of the company in the given date range.
     */
    public ProfitAndLossReport withNetOtherIncome(BigDecimal netOtherIncome) {
        Utils.checkNotNull(netOtherIncome, "netOtherIncome");
        this.netOtherIncome = netOtherIncome;
        return this;
    }

        /**
         * Net profit of the company in the given date range.
         */
    public ProfitAndLossReport withNetProfit(double netProfit) {
        this.netProfit = BigDecimal.valueOf(netProfit);
        return this;
    }

    /**
     * Net profit of the company in the given date range.
     */
    public ProfitAndLossReport withNetProfit(BigDecimal netProfit) {
        Utils.checkNotNull(netProfit, "netProfit");
        this.netProfit = netProfit;
        return this;
    }

    public ProfitAndLossReport withOtherExpenses(ReportLine otherExpenses) {
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        this.otherExpenses = Optional.ofNullable(otherExpenses);
        return this;
    }

    public ProfitAndLossReport withOtherExpenses(Optional<? extends ReportLine> otherExpenses) {
        Utils.checkNotNull(otherExpenses, "otherExpenses");
        this.otherExpenses = otherExpenses;
        return this;
    }

    public ProfitAndLossReport withOtherIncome(ReportLine otherIncome) {
        Utils.checkNotNull(otherIncome, "otherIncome");
        this.otherIncome = Optional.ofNullable(otherIncome);
        return this;
    }

    public ProfitAndLossReport withOtherIncome(Optional<? extends ReportLine> otherIncome) {
        Utils.checkNotNull(otherIncome, "otherIncome");
        this.otherIncome = otherIncome;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withToDate(String toDate) {
        Utils.checkNotNull(toDate, "toDate");
        this.toDate = Optional.ofNullable(toDate);
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public ProfitAndLossReport withToDate(Optional<String> toDate) {
        Utils.checkNotNull(toDate, "toDate");
        this.toDate = toDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ProfitAndLossReport other = (ProfitAndLossReport) o;
        return 
            Objects.deepEquals(this.costOfSales, other.costOfSales) &&
            Objects.deepEquals(this.expenses, other.expenses) &&
            Objects.deepEquals(this.fromDate, other.fromDate) &&
            Objects.deepEquals(this.grossProfit, other.grossProfit) &&
            Objects.deepEquals(this.income, other.income) &&
            Objects.deepEquals(this.netOperatingProfit, other.netOperatingProfit) &&
            Objects.deepEquals(this.netOtherIncome, other.netOtherIncome) &&
            Objects.deepEquals(this.netProfit, other.netProfit) &&
            Objects.deepEquals(this.otherExpenses, other.otherExpenses) &&
            Objects.deepEquals(this.otherIncome, other.otherIncome) &&
            Objects.deepEquals(this.toDate, other.toDate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            costOfSales,
            expenses,
            fromDate,
            grossProfit,
            income,
            netOperatingProfit,
            netOtherIncome,
            netProfit,
            otherExpenses,
            otherIncome,
            toDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ProfitAndLossReport.class,
                "costOfSales", costOfSales,
                "expenses", expenses,
                "fromDate", fromDate,
                "grossProfit", grossProfit,
                "income", income,
                "netOperatingProfit", netOperatingProfit,
                "netOtherIncome", netOtherIncome,
                "netProfit", netProfit,
                "otherExpenses", otherExpenses,
                "otherIncome", otherIncome,
                "toDate", toDate);
    }
    
    public final static class Builder {
 
        private Optional<? extends ReportLine> costOfSales = Optional.empty();
 
        private Optional<? extends ReportLine> expenses = Optional.empty();
 
        private Optional<String> fromDate = Optional.empty();
 
        private BigDecimal grossProfit;
 
        private Optional<? extends ReportLine> income = Optional.empty();
 
        private BigDecimal netOperatingProfit;
 
        private BigDecimal netOtherIncome;
 
        private BigDecimal netProfit;
 
        private Optional<? extends ReportLine> otherExpenses = Optional.empty();
 
        private Optional<? extends ReportLine> otherIncome = Optional.empty();
 
        private Optional<String> toDate = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder costOfSales(ReportLine costOfSales) {
            Utils.checkNotNull(costOfSales, "costOfSales");
            this.costOfSales = Optional.ofNullable(costOfSales);
            return this;
        }

        public Builder costOfSales(Optional<? extends ReportLine> costOfSales) {
            Utils.checkNotNull(costOfSales, "costOfSales");
            this.costOfSales = costOfSales;
            return this;
        }

        public Builder expenses(ReportLine expenses) {
            Utils.checkNotNull(expenses, "expenses");
            this.expenses = Optional.ofNullable(expenses);
            return this;
        }

        public Builder expenses(Optional<? extends ReportLine> expenses) {
            Utils.checkNotNull(expenses, "expenses");
            this.expenses = expenses;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder fromDate(String fromDate) {
            Utils.checkNotNull(fromDate, "fromDate");
            this.fromDate = Optional.ofNullable(fromDate);
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder fromDate(Optional<String> fromDate) {
            Utils.checkNotNull(fromDate, "fromDate");
            this.fromDate = fromDate;
            return this;
        }

        /**
         * Gross profit of the company in the given date range.
         */
        public Builder grossProfit(double grossProfit) {
            this.grossProfit = BigDecimal.valueOf(grossProfit);
            return this;
        }

        /**
         * Gross profit of the company in the given date range.
         */
        public Builder grossProfit(BigDecimal grossProfit) {
            Utils.checkNotNull(grossProfit, "grossProfit");
            this.grossProfit = grossProfit;
            return this;
        }

        public Builder income(ReportLine income) {
            Utils.checkNotNull(income, "income");
            this.income = Optional.ofNullable(income);
            return this;
        }

        public Builder income(Optional<? extends ReportLine> income) {
            Utils.checkNotNull(income, "income");
            this.income = income;
            return this;
        }

        /**
         * Net operating profit of the company in the given date range.
         */
        public Builder netOperatingProfit(double netOperatingProfit) {
            this.netOperatingProfit = BigDecimal.valueOf(netOperatingProfit);
            return this;
        }

        /**
         * Net operating profit of the company in the given date range.
         */
        public Builder netOperatingProfit(BigDecimal netOperatingProfit) {
            Utils.checkNotNull(netOperatingProfit, "netOperatingProfit");
            this.netOperatingProfit = netOperatingProfit;
            return this;
        }

        /**
         * Net other income of the company in the given date range.
         */
        public Builder netOtherIncome(double netOtherIncome) {
            this.netOtherIncome = BigDecimal.valueOf(netOtherIncome);
            return this;
        }

        /**
         * Net other income of the company in the given date range.
         */
        public Builder netOtherIncome(BigDecimal netOtherIncome) {
            Utils.checkNotNull(netOtherIncome, "netOtherIncome");
            this.netOtherIncome = netOtherIncome;
            return this;
        }

        /**
         * Net profit of the company in the given date range.
         */
        public Builder netProfit(double netProfit) {
            this.netProfit = BigDecimal.valueOf(netProfit);
            return this;
        }

        /**
         * Net profit of the company in the given date range.
         */
        public Builder netProfit(BigDecimal netProfit) {
            Utils.checkNotNull(netProfit, "netProfit");
            this.netProfit = netProfit;
            return this;
        }

        public Builder otherExpenses(ReportLine otherExpenses) {
            Utils.checkNotNull(otherExpenses, "otherExpenses");
            this.otherExpenses = Optional.ofNullable(otherExpenses);
            return this;
        }

        public Builder otherExpenses(Optional<? extends ReportLine> otherExpenses) {
            Utils.checkNotNull(otherExpenses, "otherExpenses");
            this.otherExpenses = otherExpenses;
            return this;
        }

        public Builder otherIncome(ReportLine otherIncome) {
            Utils.checkNotNull(otherIncome, "otherIncome");
            this.otherIncome = Optional.ofNullable(otherIncome);
            return this;
        }

        public Builder otherIncome(Optional<? extends ReportLine> otherIncome) {
            Utils.checkNotNull(otherIncome, "otherIncome");
            this.otherIncome = otherIncome;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder toDate(String toDate) {
            Utils.checkNotNull(toDate, "toDate");
            this.toDate = Optional.ofNullable(toDate);
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder toDate(Optional<String> toDate) {
            Utils.checkNotNull(toDate, "toDate");
            this.toDate = toDate;
            return this;
        }
        
        public ProfitAndLossReport build() {
            return new ProfitAndLossReport(
                costOfSales,
                expenses,
                fromDate,
                grossProfit,
                income,
                netOperatingProfit,
                netOtherIncome,
                netProfit,
                otherExpenses,
                otherIncome,
                toDate);
        }
    }
}

