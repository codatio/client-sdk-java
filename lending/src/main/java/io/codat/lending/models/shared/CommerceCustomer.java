/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package io.codat.lending.models.shared;


import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.codat.lending.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

/**
 * CommerceCustomer - When a customer places an order with the connected commerce store their details are added to the Customers dataset. You can use the data from the Customers endpoints to calculate key metrics, such as customer churn.
 */

public class CommerceCustomer {

    /**
     * Addresses of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("addresses")
    private Optional<? extends List<CommerceAddress>> addresses;

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createdDate")
    private Optional<String> createdDate;

    /**
     * Name of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customerName")
    private Optional<String> customerName;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("defaultCurrency")
    private Optional<String> defaultCurrency;

    /**
     * Email address of the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("emailAddress")
    private Optional<String> emailAddress;

    /**
     * A unique, persistent identifier for this record
     */
    @JsonProperty("id")
    private String id;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modifiedDate")
    private Optional<String> modifiedDate;

    /**
     * Any additional information about the customer
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private Optional<String> note;

    /**
     * A phone number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("phone")
    private JsonNullable<String> phone;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceModifiedDate")
    private Optional<String> sourceModifiedDate;

    @JsonCreator
    public CommerceCustomer(
            @JsonProperty("addresses") Optional<? extends List<CommerceAddress>> addresses,
            @JsonProperty("createdDate") Optional<String> createdDate,
            @JsonProperty("customerName") Optional<String> customerName,
            @JsonProperty("defaultCurrency") Optional<String> defaultCurrency,
            @JsonProperty("emailAddress") Optional<String> emailAddress,
            @JsonProperty("id") String id,
            @JsonProperty("modifiedDate") Optional<String> modifiedDate,
            @JsonProperty("note") Optional<String> note,
            @JsonProperty("phone") JsonNullable<String> phone,
            @JsonProperty("sourceModifiedDate") Optional<String> sourceModifiedDate) {
        Utils.checkNotNull(addresses, "addresses");
        Utils.checkNotNull(createdDate, "createdDate");
        Utils.checkNotNull(customerName, "customerName");
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        Utils.checkNotNull(emailAddress, "emailAddress");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        Utils.checkNotNull(note, "note");
        Utils.checkNotNull(phone, "phone");
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.addresses = addresses;
        this.createdDate = createdDate;
        this.customerName = customerName;
        this.defaultCurrency = defaultCurrency;
        this.emailAddress = emailAddress;
        this.id = id;
        this.modifiedDate = modifiedDate;
        this.note = note;
        this.phone = phone;
        this.sourceModifiedDate = sourceModifiedDate;
    }
    
    public CommerceCustomer(
            String id) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), id, Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Addresses of the customer
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CommerceAddress>> addresses() {
        return (Optional<List<CommerceAddress>>) addresses;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    @JsonIgnore
    public Optional<String> createdDate() {
        return createdDate;
    }

    /**
     * Name of the customer
     */
    @JsonIgnore
    public Optional<String> customerName() {
        return customerName;
    }

    @JsonIgnore
    public Optional<String> defaultCurrency() {
        return defaultCurrency;
    }

    /**
     * Email address of the customer
     */
    @JsonIgnore
    public Optional<String> emailAddress() {
        return emailAddress;
    }

    /**
     * A unique, persistent identifier for this record
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    @JsonIgnore
    public Optional<String> modifiedDate() {
        return modifiedDate;
    }

    /**
     * Any additional information about the customer
     */
    @JsonIgnore
    public Optional<String> note() {
        return note;
    }

    /**
     * A phone number.
     */
    @JsonIgnore
    public JsonNullable<String> phone() {
        return phone;
    }

    @JsonIgnore
    public Optional<String> sourceModifiedDate() {
        return sourceModifiedDate;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Addresses of the customer
     */
    public CommerceCustomer withAddresses(List<CommerceAddress> addresses) {
        Utils.checkNotNull(addresses, "addresses");
        this.addresses = Optional.ofNullable(addresses);
        return this;
    }

    /**
     * Addresses of the customer
     */
    public CommerceCustomer withAddresses(Optional<? extends List<CommerceAddress>> addresses) {
        Utils.checkNotNull(addresses, "addresses");
        this.addresses = addresses;
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceCustomer withCreatedDate(String createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = Optional.ofNullable(createdDate);
        return this;
    }

    /**
     * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
     * 
     * ```
     * 2020-10-08T22:40:50Z
     * 2021-01-01T00:00:00
     * ```
     * 
     * 
     * 
     * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
     * 
     * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
     * - Unqualified local time: `2021-11-15T01:00:00`
     * - UTC time offsets: `2021-11-15T01:00:00-05:00`
     * 
     * &gt; Time zones
     * &gt; 
     * &gt; Not all dates from Codat will contain information about time zones.  
     * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
     */
    public CommerceCustomer withCreatedDate(Optional<String> createdDate) {
        Utils.checkNotNull(createdDate, "createdDate");
        this.createdDate = createdDate;
        return this;
    }

    /**
     * Name of the customer
     */
    public CommerceCustomer withCustomerName(String customerName) {
        Utils.checkNotNull(customerName, "customerName");
        this.customerName = Optional.ofNullable(customerName);
        return this;
    }

    /**
     * Name of the customer
     */
    public CommerceCustomer withCustomerName(Optional<String> customerName) {
        Utils.checkNotNull(customerName, "customerName");
        this.customerName = customerName;
        return this;
    }

    public CommerceCustomer withDefaultCurrency(String defaultCurrency) {
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        this.defaultCurrency = Optional.ofNullable(defaultCurrency);
        return this;
    }

    public CommerceCustomer withDefaultCurrency(Optional<String> defaultCurrency) {
        Utils.checkNotNull(defaultCurrency, "defaultCurrency");
        this.defaultCurrency = defaultCurrency;
        return this;
    }

    /**
     * Email address of the customer
     */
    public CommerceCustomer withEmailAddress(String emailAddress) {
        Utils.checkNotNull(emailAddress, "emailAddress");
        this.emailAddress = Optional.ofNullable(emailAddress);
        return this;
    }

    /**
     * Email address of the customer
     */
    public CommerceCustomer withEmailAddress(Optional<String> emailAddress) {
        Utils.checkNotNull(emailAddress, "emailAddress");
        this.emailAddress = emailAddress;
        return this;
    }

    /**
     * A unique, persistent identifier for this record
     */
    public CommerceCustomer withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public CommerceCustomer withModifiedDate(String modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = Optional.ofNullable(modifiedDate);
        return this;
    }

    public CommerceCustomer withModifiedDate(Optional<String> modifiedDate) {
        Utils.checkNotNull(modifiedDate, "modifiedDate");
        this.modifiedDate = modifiedDate;
        return this;
    }

    /**
     * Any additional information about the customer
     */
    public CommerceCustomer withNote(String note) {
        Utils.checkNotNull(note, "note");
        this.note = Optional.ofNullable(note);
        return this;
    }

    /**
     * Any additional information about the customer
     */
    public CommerceCustomer withNote(Optional<String> note) {
        Utils.checkNotNull(note, "note");
        this.note = note;
        return this;
    }

    /**
     * A phone number.
     */
    public CommerceCustomer withPhone(String phone) {
        Utils.checkNotNull(phone, "phone");
        this.phone = JsonNullable.of(phone);
        return this;
    }

    /**
     * A phone number.
     */
    public CommerceCustomer withPhone(JsonNullable<String> phone) {
        Utils.checkNotNull(phone, "phone");
        this.phone = phone;
        return this;
    }

    public CommerceCustomer withSourceModifiedDate(String sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
        return this;
    }

    public CommerceCustomer withSourceModifiedDate(Optional<String> sourceModifiedDate) {
        Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
        this.sourceModifiedDate = sourceModifiedDate;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CommerceCustomer other = (CommerceCustomer) o;
        return 
            Objects.deepEquals(this.addresses, other.addresses) &&
            Objects.deepEquals(this.createdDate, other.createdDate) &&
            Objects.deepEquals(this.customerName, other.customerName) &&
            Objects.deepEquals(this.defaultCurrency, other.defaultCurrency) &&
            Objects.deepEquals(this.emailAddress, other.emailAddress) &&
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.modifiedDate, other.modifiedDate) &&
            Objects.deepEquals(this.note, other.note) &&
            Objects.deepEquals(this.phone, other.phone) &&
            Objects.deepEquals(this.sourceModifiedDate, other.sourceModifiedDate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            addresses,
            createdDate,
            customerName,
            defaultCurrency,
            emailAddress,
            id,
            modifiedDate,
            note,
            phone,
            sourceModifiedDate);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CommerceCustomer.class,
                "addresses", addresses,
                "createdDate", createdDate,
                "customerName", customerName,
                "defaultCurrency", defaultCurrency,
                "emailAddress", emailAddress,
                "id", id,
                "modifiedDate", modifiedDate,
                "note", note,
                "phone", phone,
                "sourceModifiedDate", sourceModifiedDate);
    }
    
    public final static class Builder {
 
        private Optional<? extends List<CommerceAddress>> addresses = Optional.empty();
 
        private Optional<String> createdDate = Optional.empty();
 
        private Optional<String> customerName = Optional.empty();
 
        private Optional<String> defaultCurrency = Optional.empty();
 
        private Optional<String> emailAddress = Optional.empty();
 
        private String id;
 
        private Optional<String> modifiedDate = Optional.empty();
 
        private Optional<String> note = Optional.empty();
 
        private JsonNullable<String> phone = JsonNullable.undefined();
 
        private Optional<String> sourceModifiedDate = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Addresses of the customer
         */
        public Builder addresses(List<CommerceAddress> addresses) {
            Utils.checkNotNull(addresses, "addresses");
            this.addresses = Optional.ofNullable(addresses);
            return this;
        }

        /**
         * Addresses of the customer
         */
        public Builder addresses(Optional<? extends List<CommerceAddress>> addresses) {
            Utils.checkNotNull(addresses, "addresses");
            this.addresses = addresses;
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(String createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = Optional.ofNullable(createdDate);
            return this;
        }

        /**
         * In Codat's data model, dates and times are represented using the &lt;a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank"&gt;ISO 8601 standard&lt;/a&gt;. Date and time fields are formatted as strings; for example:
         * 
         * ```
         * 2020-10-08T22:40:50Z
         * 2021-01-01T00:00:00
         * ```
         * 
         * 
         * 
         * When syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:
         * 
         * - Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`
         * - Unqualified local time: `2021-11-15T01:00:00`
         * - UTC time offsets: `2021-11-15T01:00:00-05:00`
         * 
         * &gt; Time zones
         * &gt; 
         * &gt; Not all dates from Codat will contain information about time zones.  
         * &gt; Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.
         */
        public Builder createdDate(Optional<String> createdDate) {
            Utils.checkNotNull(createdDate, "createdDate");
            this.createdDate = createdDate;
            return this;
        }

        /**
         * Name of the customer
         */
        public Builder customerName(String customerName) {
            Utils.checkNotNull(customerName, "customerName");
            this.customerName = Optional.ofNullable(customerName);
            return this;
        }

        /**
         * Name of the customer
         */
        public Builder customerName(Optional<String> customerName) {
            Utils.checkNotNull(customerName, "customerName");
            this.customerName = customerName;
            return this;
        }

        public Builder defaultCurrency(String defaultCurrency) {
            Utils.checkNotNull(defaultCurrency, "defaultCurrency");
            this.defaultCurrency = Optional.ofNullable(defaultCurrency);
            return this;
        }

        public Builder defaultCurrency(Optional<String> defaultCurrency) {
            Utils.checkNotNull(defaultCurrency, "defaultCurrency");
            this.defaultCurrency = defaultCurrency;
            return this;
        }

        /**
         * Email address of the customer
         */
        public Builder emailAddress(String emailAddress) {
            Utils.checkNotNull(emailAddress, "emailAddress");
            this.emailAddress = Optional.ofNullable(emailAddress);
            return this;
        }

        /**
         * Email address of the customer
         */
        public Builder emailAddress(Optional<String> emailAddress) {
            Utils.checkNotNull(emailAddress, "emailAddress");
            this.emailAddress = emailAddress;
            return this;
        }

        /**
         * A unique, persistent identifier for this record
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        public Builder modifiedDate(String modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = Optional.ofNullable(modifiedDate);
            return this;
        }

        public Builder modifiedDate(Optional<String> modifiedDate) {
            Utils.checkNotNull(modifiedDate, "modifiedDate");
            this.modifiedDate = modifiedDate;
            return this;
        }

        /**
         * Any additional information about the customer
         */
        public Builder note(String note) {
            Utils.checkNotNull(note, "note");
            this.note = Optional.ofNullable(note);
            return this;
        }

        /**
         * Any additional information about the customer
         */
        public Builder note(Optional<String> note) {
            Utils.checkNotNull(note, "note");
            this.note = note;
            return this;
        }

        /**
         * A phone number.
         */
        public Builder phone(String phone) {
            Utils.checkNotNull(phone, "phone");
            this.phone = JsonNullable.of(phone);
            return this;
        }

        /**
         * A phone number.
         */
        public Builder phone(JsonNullable<String> phone) {
            Utils.checkNotNull(phone, "phone");
            this.phone = phone;
            return this;
        }

        public Builder sourceModifiedDate(String sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = Optional.ofNullable(sourceModifiedDate);
            return this;
        }

        public Builder sourceModifiedDate(Optional<String> sourceModifiedDate) {
            Utils.checkNotNull(sourceModifiedDate, "sourceModifiedDate");
            this.sourceModifiedDate = sourceModifiedDate;
            return this;
        }
        
        public CommerceCustomer build() {
            return new CommerceCustomer(
                addresses,
                createdDate,
                customerName,
                defaultCurrency,
                emailAddress,
                id,
                modifiedDate,
                note,
                phone,
                sourceModifiedDate);
        }
    }
}

